[{"title":"Bug bounty program","type":0,"sectionRef":"#","url":"contribute/bug-bounty-program","content":"Bug bounty program","keywords":""},{"title":"Community maintainers","type":0,"sectionRef":"#","url":"contribute/community-maintainers","content":"Community maintainers","keywords":""},{"title":"Hot topics for contributors","type":0,"sectionRef":"#","url":"contribute/hot-topics-for-contributors","content":"Hot topics for contributors","keywords":""},{"title":"Rewards","type":0,"sectionRef":"#","url":"contribute/rewards","content":"Rewards","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"contribute/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"How to contribute code","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-code","content":"How to contribute code","keywords":""},{"title":"How to","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to","content":"How to","keywords":""},{"title":"How to contribute to website","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-to-website","content":"How to contribute to website","keywords":""},{"title":"How to contribute to docs","type":0,"sectionRef":"#","url":"contribute/tutorial/how-to-contribute-to-docs","content":"How to contribute to docs","keywords":""},{"title":"Accounts","type":0,"sectionRef":"#","url":"develop/architecture/accounts","content":"Accounts","keywords":""},{"title":"Eever OS","type":0,"sectionRef":"#","url":"develop/architecture/ever-os","content":"Eever OS","keywords":""},{"title":"Contract composition","type":0,"sectionRef":"#","url":"develop/architecture/contract-composition","content":"Contract composition","keywords":""},{"title":"Message","type":0,"sectionRef":"#","url":"develop/architecture/message","content":"Message","keywords":""},{"title":"Querying","type":0,"sectionRef":"#","url":"develop/architecture/querying","content":"Querying","keywords":""},{"title":"Runtime","type":0,"sectionRef":"#","url":"develop/architecture/runtime","content":"Runtime","keywords":""},{"title":"Serialization","type":0,"sectionRef":"#","url":"develop/architecture/serialization","content":"Serialization","keywords":""},{"title":"Transaction","type":0,"sectionRef":"#","url":"develop/architecture/transaction","content":"Transaction","keywords":""},{"title":"Comparison with Bitcoin","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-bitcoin","content":"Comparison with Bitcoin","keywords":""},{"title":"Comparison with Ethereum","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-ethereum","content":"Comparison with Ethereum","keywords":""},{"title":"Comparison with Solana","type":0,"sectionRef":"#","url":"develop/from-another-platform/comparison-with-solana","content":"Comparison with Solana","keywords":""},{"title":"Hackathons & Grants","type":0,"sectionRef":"#","url":"develop/hackathons-grants","content":"Hackathons &amp; Grants","keywords":""},{"title":"Comparison with EVM Solidity Contracts","type":0,"sectionRef":"#","url":"develop/smart-contract/comparison-with-evm-solidity","content":"Comparison with EVM Solidity Contracts","keywords":""},{"title":"Components","type":0,"sectionRef":"#","url":"develop/smart-contract/components","content":"Components","keywords":""},{"title":"Debugging","type":0,"sectionRef":"#","url":"develop/smart-contract/debugging","content":"Debugging","keywords":""},{"title":"Developing with C++","type":0,"sectionRef":"#","url":"develop/smart-contract/developing-with-c++","content":"Developing with C++","keywords":""},{"title":"Developing with TVM Solidity","type":0,"sectionRef":"#","url":"develop/smart-contract/developing-with-tvm-solidity","content":"Developing with TVM Solidity","keywords":""},{"title":"Examples","type":0,"sectionRef":"#","url":"develop/smart-contract/examples","content":"Examples","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"develop/smart-contract/faq","content":"FAQ","keywords":""},{"title":"Frontend App","type":0,"sectionRef":"#","url":"develop/smart-contract/frontend-app","content":"Frontend App","keywords":""},{"title":"Lifecycle","type":0,"sectionRef":"#","url":"develop/smart-contract/lifecycle","content":"Lifecycle","keywords":""},{"title":"Math","type":0,"sectionRef":"#","url":"develop/smart-contract/math","content":"Math","keywords":""},{"title":"Migration Guide","type":0,"sectionRef":"#","url":"develop/smart-contract/migration-guide","content":"Migration Guide","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/smart-contract/getting-started","content":"","keywords":""},{"title":"Prerequisite​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#prerequisite","content":"Node.js &gt;= 14.x installed Node Version Manager (NVM)NVM-windows Docker &gt;= 19.x installed and running "},{"title":"Generate a new project​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-a-new-project","content":"mkdir my-project &amp;&amp; cd $_ npm init --force npm install --save everdev  "},{"title":"Setup local environment​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#setup-local-environment","content":"Set Local Blockchain SE (Startup Edition) as the default network: Startup SE at this step, you may have to wait until the docker image is downloaded: npx everdev se start  A local network explorer is available at localhost check it. Setting SE as default network: npx everdev network default se  "},{"title":"Configure Giver​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#configure-giver","content":"Configure Giver wallet that will sponsor EVER for deploy operation: npx everdev signer add giver 172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3 npx everdev network giver se 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver npx everdev network giver dev 0:b5e9240fc2d2f1ff8cbb1d1dee7fb7cae155e5f6320e585fcc685698994a19a5 --signer giver  "},{"title":"Generate the key pair for contract ownership​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-the-key-pair-for-contract-ownership","content":"Key pair file — used in contracts with implemented authorization. It is the file containing private and public keys authorized to access the contract. In --sign parameter the corresponding seed phrase may be used instead of it. npx everdev signer generate coder npx everdev signer default coder npx everdev signer list  "},{"title":"Generate a new smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#generate-a-new-smart-contract","content":"npx everdev sol create App  You are got App.sol: pragma ton-solidity &gt;= 0.35.0; pragma AbiHeader expire; // This is class that describes you smart contract. contract App { // Contract can have an instance variables. // In this example instance variable `timestamp` // is used to store the time of `constructor` // or `touch` function call. uint32 public timestamp; // Contract can have a `constructor`. // The function that will be called when contract will be deployed to the blockchain. // In this example constructor adds current time to the instance variable. // All contracts need call `tvm.accept()` for succeeded deploy. constructor() public { // Check that contract's public key is set require(tvm.pubkey() != 0, 101); // Check that message has signature (msg.pubkey() is not zero) and // message is signed with the owner's private key require(msg.pubkey() == tvm.pubkey(), 102); // The current smart contract agrees to buy some gas to finish the // current transaction. This actions required to process external // messages, which bring no value (hence no gas) with themselves. tvm.accept(); timestamp = now; } function renderHelloWorld () public pure returns (string) { return 'helloWorld'; } // Updates variable `timestamp` with current blockchain time. function touch() external { // Each function that accepts external message must check that // message is correctly signed. require(msg.pubkey() == tvm.pubkey(), 102); // Tells to the TVM that we accept this message. tvm.accept(); // Update timestamp timestamp = now; } function sendValue(address dest, uint128 amount, bool bounce) public view { require(msg.pubkey() == tvm.pubkey(), 102); tvm.accept(); // It allows to make a transfer with arbitrary settings dest.transfer(amount, bounce, 0); } }  For more about Solidity and specific of Everscale Solidity "},{"title":"Compile smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#compile-smart-contract","content":"npx everdev sol compile App.sol  You are got: App.abi.json — ABI *.abi.json file — a file that describes the contract interface, the methods and parameters used to interact with it, for detail see ABI Specification V2.App.tvc — TVC *.tvc file — the compiled smart contract file. Used only when generating contract address and deploying contract code to the blockchain. "},{"title":"Deploy smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#deploy-smart-contract","content":"The 1 EVER is 1000000000 nano EVER Local network: npx everdev contract deploy --network se --value 1000000000 App  Developer network: npx everdev contract deploy --network dev --value 1000000000 App  "},{"title":"Address smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#address-smart-contract","content":"Address of smart-contract is calculated from TVC and signer (coder) public: npx everdev contract info --network se --signer coder App  Getting only address: appAddress=$(npx everdev contract info --network se --signer coder App | grep Address | cut -d ' ' -f 4) echo $appAddress  "},{"title":"Interact with smart-contract​","type":1,"pageTitle":"Getting started","url":"develop/smart-contract/getting-started#interact-with-smart-contract","content":"Read: npx everdev contract run-local --network se App renderHelloWorld npx everdev contract run-local --network se App timestamp  Write: npx everdev contract run --network se --signer coder App touch  For more details see: Get started with Development Tools. "},{"title":"Verifying Smart Contract","type":0,"sectionRef":"#","url":"develop/smart-contract/verifying-smart-contract","content":"Verifying Smart Contract","keywords":""},{"title":"Issue a Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/issue-ft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Issue a Fungible Token","url":"develop/smart-digital-assets/issue-ft#reference","content":"TIP-3 Core description "},{"title":"Mint a Non-Fungible Token","type":0,"sectionRef":"#","url":"develop/smart-digital-assets/mint-nft","content":"","keywords":""},{"title":"Reference​","type":1,"pageTitle":"Mint a Non-Fungible Token","url":"develop/smart-digital-assets/mint-nft#reference","content":"TIP-4 Core description "},{"title":"Ever OS CLI","type":0,"sectionRef":"#","url":"develop/software/everos-cli","content":"Ever OS CLI","keywords":""},{"title":"SDK","type":0,"sectionRef":"#","url":"develop/software/sdk","content":"SDK","keywords":""},{"title":"API","type":0,"sectionRef":"#","url":"develop/software/api","content":"API","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"develop/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"Tutorial 1","type":0,"sectionRef":"#","url":"develop/tutorial/tutorial-1","content":"Tutorial 1","keywords":""},{"title":"Tutorial 2","type":0,"sectionRef":"#","url":"develop/tutorial/tutorial-2","content":"Tutorial 2","keywords":""},{"title":"API","type":0,"sectionRef":"#","url":"integrate/client/api","content":"API","keywords":""},{"title":"Bridge integration","type":0,"sectionRef":"#","url":"integrate/bridge-integration","content":"Bridge integration","keywords":""},{"title":"SDK","type":0,"sectionRef":"#","url":"integrate/client/sdk","content":"SDK","keywords":""},{"title":"Add Everscale to your Exchange","type":0,"sectionRef":"#","url":"integrate/tutorial/add-everscale-to-your-exchange","content":"Add Everscale to your Exchange","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"integrate/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"Blockchain basis","type":0,"sectionRef":"#","url":"learn/blockchain-basis","content":"Blockchain basis","keywords":""},{"title":"How to read Network details","type":0,"sectionRef":"#","url":"integrate/tutorial/how-to-read-network-details","content":"How to read Network details","keywords":""},{"title":"DePool Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/depool-specifications","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#background","content":"It is quite evident that to achieve high-performance properties, a network needs powerful, reliable servers with fast connectivity. At the same time, to achieve sufficient decentralization, these servers have to belong to as many owners as possible. There seems to be a contradiction between these goals. In Proof-of-Work networks, performance is often sacrificed for decentralization. Yet, claims arise that the centralization of Bitcoin, Ethereum etc. mining power is not entirely prevented. Mining Pools centralization remains an issue, as these pools are controlled by particular entities distributing rewards. For example, almost 60% of Bitcoin mining power is concentrated in just 4 pools and around 80% of all mining power originates in China. Just 2 mining pools control 52% of Ethereum hashrate, more than 50% of which originates in China. In Proof-of-Stake, the correlation between network performance and concentration of power (money in this case) is even more apparent, as one does not need to buy, set up, and manage complicated mining farms. It can ultimately be claimed that POS is trading performance for decentralization (look no further than EOS centralization, Steemit network overtaking etc.). It seems that enabling small token holders to participate in network governance is a very important decentralization property. "},{"title":"Motivation​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#motivation","content":"Everscale blockchain needs all newly created blocks to be validated in order to run correctly. For this it relies on special designated nodes called &quot;Validators&quot;, and offers substantial reward for their work. However, becoming a validator requires a substantial cryptocurrency deposit. The required amount might far exceed an individual validator budget. On the other hand, blockchain users with no validating system might be interested in investing in validation duty. This is where the Decentralized Pool (DePool) smart contract comes in. There are two main use cases of DePool: User has no Validator capabilities but some free funds. User can support a third-party Validator and receive rewards.User has Validator capabilities and but doesn't have necessary amount of funds to participate in validator elections and subsequent rewards. "},{"title":"Basic terms​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#basic-terms","content":"DePool — a smart contract that allows other smart contracts to invest stakes into a common pool of funds and after some period of time to receive it back with interest.Elector — a system level smart contract, deployed to masterchain from zero state. Runs validator elections periodically.DePool Proxy (proxy) — a smart contract that delivers messages between DePool and Elector.Participant — a smart contract that invests funds into DePool.Validator — software running blockchain node. Each DePool works with one node only. This node must be a DePool participant.Validator wallet — a smart contract that is used by Validator to send election requests to DePool and receive the Validator reward. Validator wallet should be a Multisig contract with 3 custodians.DePool Helper — a smart contract that stores the address of the actual DePool and works with the Timer contract.Global Validators Set (GVS) — current set of validators chosen in the latest elections.Validation period — period of time for which GVS is elected.Investment round — period of time between Participant investing a stake in DePool and receiving it back (with or without interest).Timer — a smart contract that can call other smart contracts periodically. "},{"title":"Architecture​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#architecture","content":" DePool is designed to receive investment stakes from Participants, allocate the pool funds to a validator in order to participate in elections of the GVS and, after the end of the validation cycle, distribute stakes with certain rewards back to the Participants.DePool is deployed to basechain. But it cannot communicate with Elector directly, because Elector rejects messages from non-masterchain contracts. Thus there are DePool proxies that are deployed to masterchain and deliver messages from DePool to Elector and back. This is done, because DePool is a large and complex contract, and gas and storage fees are 10 times lower in basechain compared to masterchain. Keeping DePool on masterchain would be unreasonably expensive.DePool is open for Participants’ stakes at all times, however, there is a deadline for participation in the upcoming elections. The deadline depends on the timer of the Elector. After the deadline, the incoming stakes will be accumulated for participation in the next elections.DePool distinguishes stakes received before the deadline and after the deadline, therefore it stores information on Participant stakes in separate investment rounds (or rounds), one for every elections, to facilitate subsequent distribution of stakes and rewards. To separate Elector communication, DePool uses 2 proxies: one for even rounds, one for odd.In order to be time-aware, the DePool should be called from time to time. For this purpose the Timer contract is used. DePool Helper asks Timer to call it periodically and transmits every call from Timer to DePool. Interval between calls is chosen according to the elections interval.DePool must be linked to a validator wallet to participate in elections on behalf of the latter. This validator wallet address is specified during DePool deployment and cannot be changed afterwards. When elections start, DePool waits for signed election requests from linked wallet, then attaches round stake to request and transmits it to Elector.Validator can validate many DePools with 1 Validator wallet. Reputation of Validator wallet therefore is available and can be analyzed over time.To ensure that the validator will perform its functions correctly (be always online and not &quot;lie&quot; to other validators), the validator wallet must itself become a Participant and invest in every investment round at least m_validatorAssurance, which is initialized in DePool constructor. This can be achieved with any of the three available types of stakes.When Elector unfreezes validator stakes, DePool returns its stake back with round rewards. Part of the total reward is used to top up the DePool's own balance to a certain value. The rest is distributed as follows: m_validatorRewardFraction% goes to Validator wallet balance. m_participantRewardFraction% is distributed among all Participants in investment round (validator is also participant). m_associationRewardFraction% (can be equal to zero) goes to m_association address.DePool keeps a balance for each Participant and can automatically reinvest Participant's stake into the next investment round if appropriate flag is enabled.Participant can transfer part of its total stake to another Participant's stake inside DePool storage. This function allows for collateralization of the stake to provide liquidity to stake holders. "},{"title":"Special kinds of stakes​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#special-kinds-of-stakes","content":"Along with the basic ordinary stake, that functions according to the rules detailed above, there are 2 types of special stakes: vesting and lock stake. While the entire ordinary stake is invested into the current pooling round (and will thus be reinvested every second round), lock and vesting stakes are split into two equal parts upon reception, which are invested into the current pooling round, and the next round. This way they can be continuously reinvested into both odd and even rounds. "},{"title":"Vesting Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#vesting-stake","content":"Any address can make a vesting stake and define a target participant address (beneficiary) who will own this stake. But not the whole stake is available to the beneficiary at once. Instead it is split into logical parts and the next part of stake becomes available to the participant only when next vesting period is ended. At completion step of every round DePool decides how many vesting parts should be unlocked and subtracted from vesting stake and become available to owner since last unlocking. These funds are added to beneficiary's ordinary stake. Example: address A makes a vesting stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address B and 110 tons are still locked in the pool. After 1 year vesting stake will be equal to 0 and last 10 tons will become available to owner. Vesting for validator beneficiaries is subject to additional rules: At the end of every withdrawal period, the part of the vesting stake to be released is divided proportionally into 2 parts — for rounds in this period when DePool successfully completed validation and received a reward (without slashing) and for rounds when DePool missed elections or was slashed. The portion of the stake corresponding to the successful rounds is sent to the validator, while the portion corresponding to the failed rounds is returned to the vesting stake owner. For example, if there were 100 rounds within the withdrawal period, and DePool successfully completed 80 of them, missed elections in 5 more and was slashed in the remaining 15, the validator will receive 80% of the unlocked part of the vesting stake, and the stake owner will get back 20% of it. "},{"title":"Lock Stake​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#lock-stake","content":"Any address can make a lock stake, in which it locks its funds in DePool for a defined period, but rewards from this stake will be payed to another target participant (beneficiary). At the end of a period the Lock Stake should be returned to the address which locked it. Example: address A makes a lock stake of 120 tons for 1 year with vesting period of 1 month and defines address B as the stake beneficiary. It means that after 1 month 10 tons become available to address A (as opposed to vesting, where these 10 tons would become available to address B, the beneficiary) and 110 tons are still locked in round. DePool will reinvest the gradually diminishing lock stake for a 1 year and pay rewards to B address. After 1 year DePool will return the remainder of the lock stake to address A. One Participant can be a beneficiary only of one lock and one vesting stake. Once current lock or vesting stake of the participant expires, it can be repeated. When a stake of either of these types is created, it is split equally into two last rounds, which means that the minimal value for such stake is 2 * minStake + fee. "},{"title":"Specification​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#specification","content":""},{"title":"Data Structures​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#data-structures","content":"DePool contract uses library and inheritance from several simple base contacts to separate functionality and facilitate development and debugging of the contract. The core data set stored by DePool is the following: DePoolLib.sol // Describes contract who deposit stakes in DePool pool struct Participant { // Count of rounds in which participant takes a part uint8 roundQty; // Sum of all rewards from completed rounds (for logging) uint64 reward; // count of parts of vesting stakes in the rounds uint8 vestingParts; // count of parts of lock stakes in the rounds uint8 lockParts; // Flag whether to reinvest ordinary stakes and rewards bool reinvest; // Target tons that will be transferred to participant after rounds are completed // After each round this value is decreased uint64 withdrawValue; } // Request for elections from validator wallet. struct Request { // Random query id. uint64 queryId; // Validator's public key that will be used as validator key if validator will win elections. uint256 validatorKey; // current election id. uint32 stakeAt; // Validator's stake factor. uint32 maxFactor; // Validator's address in adnl overlay network. uint256 adnlAddr; // Ed25519 signature of above values. bytes signature; }  DePoolRounds.sol // roundPre0 = m_rounds[m_roundQty - 1] — pre-pooling. Helper round for adding vesting and lock // stakes. When vesting/lock stake is added than stake is // split into two part. And first part invested into pooling // round and second part — pre-pooling. // // round0 = m_rounds[m_roundQty - 2] — pooling // round1 = m_rounds[m_roundQty - 3] — election or validation // round2 = m_rounds[m_roundQty - 4] — validation or investigation // Algo of round rotation: // delete round2 // round1 -&gt; round2 // round0 -&gt; round1 // roundPre0 -&gt; round0 // createNewRound -&gt; roundPre0 mapping(uint64 =&gt; Round) m_rounds; // count of created rounds uint64 m_roundQty = 0;  DePoolBase.sol // Dictionary of participants for rounds mapping (address =&gt; Participant) m_participants; // Address of the validator wallet address m_validatorWallet; // Array of proxies addresses. address[] m_proxies;  DePool.sol // Indicates that pool is closed. Closed pool doesn't accept stakes from other contracts. bool m_poolClosed; // Min stake accepted to the pool in nTon (for gas efficiency reasons): 10 tons is recommended. uint64 m_minStake; // Minimum validator stake in each round uint64 m_validatorAssurance; // % of participant rewards uint8 m_participantRewardFraction; // % of validator rewards uint8 m_validatorRewardFraction; // % of dePool association rewards uint8 m_associationRewardFraction; // Association address address m_association; // Minimum balance uint64 m_minimumBalance;  "},{"title":"DePool Initialization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-initialization","content":"When deployed, the DePool constructor is called with the following parameters: /// @dev DePool's constructor. /// @param minStake Min stake that participant may have in one round. /// @param validatorAssurance Min validator stake. /// @param proxyCode Code of proxy contract. /// @param validatorWallet Address of validator wallet. /// @param participantRewardFraction % of reward that distributed among participants. constructor( uint64 minStake, uint64 validatorAssurance, TvmCell proxyCode, address validatorWallet, uint8 participantRewardFraction, )  At initialization the variable m_balanceThreshold is set as current DePool account balance — 5 tokens. DePool will replenish its balance from validation rewards to this value every round it receives rewards. "},{"title":"Participant functions​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-functions","content":"DePool stores some participant information in a dictionary (m_participants) where key — Participant's address and value — Participant structure. Functions used by participants perform checks and send receiveAnswer message back to the caller with an error code and a comment in case of failure. If all conditions are met, DePool sends a confirmation message (receiveAnswer with status 0) back to the caller. All functions can be called by internal messages only. addOrdinaryStake(uint64 stake) — allows to make an ordinary stake in the current pooling round. The source address of the message is taken as Participant's address. The Participant's total stake is increased by stake amount. Parameters: stake — value of participant's stake in nanotons. Function checks that: inbound message value is at least (stake + ADD_STAKE_FEE);stake is at least min stake;pool is not closed. Function returns change (part of unused ADD_STAKE_FEE). addVestingStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a vesting stake for another participant (beneficiary). The source address of the message is saved as the vesting stake owner. Parameters: stake — value of participant's stake in nanotons (Note: this value is divided into 2 parts and is added to 2 rounds).beneficiary — address of target participant (beneficiary);withdrawalPeriod — the period in seconds after which the part of the vesting becomes available for beneficiary;totalPeriod — total period of vesting in seconds after which beneficiary becomes owner of the whole stake. Function checks that: DePool is not closed (m_poolClosed ≠ true);beneficiary is an addr_std. It's not zero address. It's not the message sender (not self vesting);inbound msg.value ≥ (m_minStake + ADD_STAKE_FEE);Message value is at least stake + STAKE_FEE;stake / 2 is at least min stake;withdrawalPeriod ≤ totalPeriod;totalPeriod &lt; 18 years;withdrawalPeriod ≠ 0;totalPeriod % withdrawalPeriod = 0;beneficiary doesn't have a vesting stake. addLockStake(uint64 stake, address beneficiary, uint32 withdrawalPeriod, uint32 totalPeriod) — allows to add a stake that will bring rewards to another participant (beneficiary). The source address of the message is saved as the lock stake owner. It has the same parameters and checks as addVestingStake, but it checks that participant doesn't have a lock stake instead of a vesting stake. withdrawFromPoolingRound(uint64 withdrawValue) — allows to remove Participant's stake from the current pooling round. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: inbound msg.sender address is address of an existing participant. If real ordinary stake is less than withdrawValue, then DePool returns the whole stake from pooling round. If the remaining stake in the pooling round is less than m_minStake, then the whole stake is transferred to Participant. If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. withdrawPart(uint64 withdrawValue) — Allows a participant to withdraw some value from DePool. This function withdraws withdrawValue nanotons when rounds are completed. If participant stake becomes less than minStake, then the whole stake is sent to participant. Parameters: withdrawValue — desired amount of stake to be removed. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. If the remaining stake in the round is less than m_minStake, then the whole stake will be transferred to Participant (after completing round). If the remaining total stake of Participant is 0, then it is removed from the m_stakeholders dictionary. 6. withdrawAll() — Set global flag for the participant that indicates to return participant's ordinary stake after completing rounds. Function checks that: pool is not closed (m_poolClosed ≠ true);inbound msg.sender address is address of an existing participant. After transferring all Participant's stake, the Participant will be removed from the m_stakeholders dictionary. cancelWithdrawal() — Cancel effect of calls of functions withdrawAll and withdrawPart. transferStake(address dest, uint64 amount) — allows to move amount of stake from msg.sender Participant to dest Participant inside DePool storage. Parameters: dest — stake beneficiary;amount — stake value transferred to dest in nanotons. Function checks that: pool is not closed (m_poolClosed ≠ true);destination is a non-zero addr_std;msg.sender ≠ dest;neither destination nor msg.sender is the validator wallet;inbound msg.sender address is address of an existing participant;desired amount can be transferred and transfer doesn't leave stake less than m_minStake in any round. In case of success DePool sends back a notification via onTransfer function calling to beneficiary. "},{"title":"Functions of interface DePoolInfoGetter:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#functions-of-interface-depoolinfogetter","content":"function getLastRoundInfo() public If there is no completed round yet, call callback function receiveDePoolInfo with struct containing default values, else send call with struct containing info about last completed round. // Represent info about last completed round struct LastRoundInfo { uint32 supposedElectedAt; uint8 participantRewardFraction; uint8 validatorRewardFraction; uint32 participantQty; uint64 roundStake; address validatorWallet; uint256 validatorPubkey; uint64 validatorAssurance; }  "},{"title":"Participant callback functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#participant-callback-functions","content":"These functions are called by DePool to send notifications to Participant. receiveAnswer(uint32 errcode, uint64 comment) — function, which is called as an answer from DePool to Participant. Arguments: errcode — error code. List of codes: uint8 constant STATUS_SUCCESS = 0; uint8 constant STATUS_STAKE_TOO_SMALL = 1; uint8 constant STATUS_DEPOOL_CLOSED = 3; uint8 constant STATUS_NO_PARTICIPANT = 6; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_VESTING = 9; uint8 constant STATUS_WITHDRAWAL_PERIOD_GREATER_TOTAL_PERIOD = 10; uint8 constant STATUS_TOTAL_PERIOD_MORE_18YEARS = 11; uint8 constant STATUS_WITHDRAWAL_PERIOD_IS_ZERO = 12; uint8 constant STATUS_TOTAL_PERIOD_IS_NOT_DIVED_BY_WITHDRAWAL_PERIOD = 13; uint8 constant STATUS_PERIOD_PAYMENT_IS_ZERO = 14; uint8 constant STATUS_REMAINING_STAKE_LESS_THAN_MINIMAL = 16; uint8 constant STATUS_PARTICIPANT_HAVE_ALREADY_LOCK = 17; uint8 constant STATUS_TRANSFER_AMOUNT_IS_TOO_BIG = 18; uint8 constant STATUS_TRANSFER_SELF = 19; uint8 constant STATUS_TRANSFER_TO_OR_FROM_VALIDATOR = 20; uint8 constant STATUS_FEE_TOO_SMALL = 21; uint8 constant STATUS_INVALID_ADDRESS = 22; uint8 constant STATUS_INVALID_BENEFICIARY = 23; uint8 constant STATUS_NO_ELECTION_ROUND = 24; uint8 constant STATUS_INVALID_ELECTION_ID = 25;  comment — some value attached to error code. onTransfer(address source, uint128 amount) — function, which is called after successful transferStake to inform beneficiary. Arguments: source — address of Participant who made transfer;amount — funds that were transferred. onRoundComplete(uint64 roundId, uint64 reward, uint64 ordinaryStake, uint64 vestingStake, uint64 lockStake, bool reinvest, uint8 reason) — send a notification from DePool to Participant when round is completed: roundId — Id of completed round;reward — Participant's reward in completed round in nanotons;ordinaryStake — ordinary stake in completed round;vestingStake — vesting stake in completed round;lockStake — lock stake in completed round;reinvest — are ordinary stakes automatically reinvested (prolonged)?reason — reason why round is completed (See enum CompletionReason). "},{"title":"DePool owner functions:​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-owner-functions","content":"These functions can be called only by the DePool owner, as they have to be signed with the deploy keypair. terminator() [external msg only] — a method to close DePool. All stakes from all rounds are returned in several phases: a. first of all, stakes from pooling round are returned immediately. b.m_poolClosed = true; c. All other rounds will return stakes after their &quot;completed&quot; step. Important: remaining parts of vesting/lock stakes will be sent to owners of those stakes (not to beneficiaries) setValidatorRewardFraction(uint8 fraction) [external msg only] Sets new validator's reward fraction and calculates new participants' reward fraction. New validator's reward fraction must be less than current one and be not zero. fraction — new validator's reward fraction. "},{"title":"Events​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#events","content":"DePoolClosed() — event emitted when pool is closed by terminator() function.RoundStakeIsAccepted(uint64 queryId, uint32 comment) — event is emitted on accepting stake by elector.RoundStakeIsRejected(uint64 queryId, uint32 comment) — event is emitted on rejecting stake by elector.ProxyHasRejectedTheStake(uint64 queryId) — event is emitted if stake is returned by proxy (IProxy.process_new_stake) because too low balance of proxy contract.ProxyHasRejectedRecoverRequest(uint64 roundId) — event is emitted if stake cannot be returned from elector (IProxy.recover_stake) because too low balance of proxy contract.RoundCompleted(TruncatedRound round) — event is emitted on completing round.StakeSigningRequested(uint32 electionId, address proxy) — Event emitted when round is switched from pooling to election. DePool is waiting for signed election request from validator wallet.TooLowDePoolBalance(uint replenishment) — event emitted when pure DePool's balance becomes too low. replenishment minimal value that must be sent to DePool via receiveFunds function.RewardFractionsChanged(uint8 validator, uint8 participants) — event emitted when contract owner changes reward fractions. validator — validator's reward fraction. participants — participants' reward fraction. "},{"title":"Get-methods​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#get-methods","content":"These get-methods are used for local run. getParticipantInfo(address addr) — returns participant's information about stakes in every rounds;getDePoolInfo() — returns DePool configuration parameters and constants;getParticipants() — return list of all participants;getRounds() — returns information about all rounds.getDePoolBalance() — returns DePool's own balance in nanotokens. The DePool does not store validator public keys or ADNL address, because, according to the official Everscale guide, the Validator generates a new keypair and ADNL for every elections. The contract stores only Validator wallet address. "},{"title":"State update function​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#state-update-function","content":"ticktock() — this function is the &quot;engine&quot; of DePool. This function rotates rounds: creates a new round if necessary and removes an old one. Switches steps of rounds and calls various internal functions if certain conditions are satisfied and so on. ticktock() — does not accept external inbound messages and can be called only from other contracts ticktock returns unspent message value (change) back to caller. "},{"title":"Multi-Round elections​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#multi-round-elections","content":" Every round goes through several steps: &quot;PrePooling&quot; step (RoundStep.PrePooling) — it's an imaginary round introduced to store half of vesting/lock stake from participants. See addVestingStake/addLockStake functions.&quot;Pooling&quot; step (RoundStep.Pooling) — round is ready to accept stakes from Participants. This round receives ordinary, vesting and lock stakes.&quot;waiting for election requests&quot; step (RoundStep.WaitingValidatorRequest) — round is switched to this step when validator elections begin. DePool is waiting for signed election request from validator wallet. See process_new_stake function of Elector to properly generate election request. Important: Validator wallet must also be a Participant and invest at least m_validatorAssurance stake in the round. If it doesn't, round is completed and stakes are reinvested in another round or are returned to participants. &quot;Waiting if stake is accepted by elector&quot; (RoundStep.WaitingIfStakeAccepted) — DePool has received the validator signed election request. DePool has sent the whole round stake to elector through one of its proxies. Now DePool is waiting for elector answer. Note: elector will call DePool's onStakeAccept function if election request is accepted successfully or onStakeReject in case of an error.&quot;waiting for validation start&quot; (RoundStep.WaitingValidationStart) — round stake was accepted by elector. Validator is a candidate. DePool now is waiting for the start of the validation to find out if validator won the elections.&quot;waiting for election result&quot; (RoundStep.WaitingIfValidatorWinElections) — DePool has tried to recover stake in validation period to find out if validator won elections. Waiting for elector answer. Note: If validator won the elections, elector returns no stake. If Validator lost the elections, elector returns the whole stake.&quot;waiting stake unfreeze&quot; (RoundStep.WaitingUnfreeze) — If CompletionReason != Undefined, the round is waiting round rotation to return/reinvest funds because elections were lost. Else validator won elections. DePool is waiting for ending of unfreeze period to recover funds from elector.&quot;waiting for a reward&quot; (RoundStep.WaitingReward) — Unfreeze period has been ended. Request to recover stake has been sent to elector. DePool is waiting for answer from elector.&quot;completing&quot; step (RoundStep.Completing) — DePool receives reward and replenishes its balance from it. Then it returns or reinvests participant's stakes. Also on this step DePool recounts vesting and lock stakes and modifies them if necessary.&quot;completed&quot; (RoundStep.Completed) — round switches to this step after processing all the Participants in the round. In next ticktock this round will be deleted. "},{"title":"Round completion​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#round-completion","content":"When a round switches to &quot;completing&quot; step (completeRound function), the DePool replenishes its balance from received rewards and then starts to cycle through all stakes in the round. If Participant's reinvestment flag is false, DePool sends it back to the Participant, otherwise — adds it to the pooling round. Also DePool sends notification message (onRoundComplete) to Participant. DePool goes through all vesting and lock stakes of the completing round and checks whether a withdrawal period has finished for the current stake. If it has, DePool modifies the stake via transferring part of it to Participants ordinary stake (in case of Vesting) and/or transferring part of the stake back to the owner (in case of Lock or in case of Vesting for validator which was slashed or lost elections over the course of the completed withdrawal period). Remark: if there are 15000 stakes in round, then the contract should split completion to 375 transactions sending 375 completePendingRound messages to itself. All these transactions can fit in 1-2 blocks and the whole operation will take about 5-20 seconds. "},{"title":"DePool decentralization​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-decentralization","content":"No inherent way to replace the contract code (no SETCODE);No inherent way to transfer an arbitrary amount of currency from the DePool;Any contract can call the ticktock() function to update the state of the DePool;No one has special privileges, except for deployer of DePool who can only close DePool and start a procedure of returning all stakes back to Participants;Fees cannot be changed after the contract is deployed;Validator wallet must be a Participant as well to share risks with other Participants. "},{"title":"DePool contract fee​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#depool-contract-fee","content":"Caller of DePool's ticktock function must pay for consumed gas. Unused message value is returned back when ticktock is finished. At the beginning of completing step DePool first takes from the total reward an amount of tokens to replenish it's balance to m_balanceThreshold, and then additionally RET_OR_REINV_FEE * (N + 1), where N is the number of participants, to cover the costs of stake processing. "},{"title":"Links​","type":1,"pageTitle":"DePool Specifications","url":"learn/decentralization/depool-specifications#links","content":"DePool contract is available on github. DePool deployment instructions can be found here. "},{"title":"DeBot Specifications","type":0,"sectionRef":"#","url":"learn/decentralization/debot-specifications","content":"","keywords":""},{"title":"Objective​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#objective","content":"Provide a secure and convenient environment to work with smart-contracts emulate calling smart-contract functions locally on the client;debug blockchain transactions;interact with smart-contracts deployed in the blockchain. "},{"title":"Basic terms​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#basic-terms","content":"DeBot — a smart contract facilitating conversation-like flow communication with a target smart contract;Target smart contract — a smart contract for which DeBot is created. DeBot is an interface to this smart contract;DeBot protocol — a set of rules describing the communication between browser and DeBot: how to call DeBot functions and how to interpret its answers;DeBot engine (DEngine) — a program component that executes DeBot and parses its answer using DeBot protocol;DeBot browser — a program, which creates instances of DEngine for executed DeBot and renders the user interface. "},{"title":"Architecture​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#architecture","content":" DeBot platform consists of the following elements: DeBot smart contract;DeBot browser;Target smart contract(s). One target smart contract can have several DeBot and vise versa. DeBot is deployed to the blockchain. DeBot browser runs on client. It downloads DeBot code and runs it inside the DEngine. "},{"title":"Proof of State​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#proof-of-state","content":"Transactions can be verified by running DeBot locally and comparing the result of execution to the account state in the blockchain. "},{"title":"DeBot Interfaces​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-interfaces","content":""},{"title":"Motivation​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#motivation","content":"DeBot is a smart contract and smart contracts are isolated from each other and from the blockchain, their capabilities are limited by the commands of the virtual machine on which they are executed. But DeBot must have more possibilities. DeBot need to: receive input from users;query info about other smart contracts;query transactions and messages;receive data from external subsystems (like file system) and external devices (like NFC, camera and so on);call external function libraries that allow to do operations that are not supported by VM. For example, work with json, convert numbers to string and vice versa, encrypt/decrypt/sign data. To cover all these needs we should design different DeBot Interfaces (DInterfaces) which can be used in DeBot and which must be supported in DeBot Browsers. These interfaces should match the requirements: comprehensive — interfaces should describe all types of communication accessible on modern devices;universal — interfaces should be abstract from certain OS and hardware;atomic — every communication channel should be separately described in the interface for further flexible resource access management;convenient — even low-skilled developers should be able to use this interface in their DeBot. In this model DeBot Engine should act like a proxy between DeBot Browser and DeBot. But it can have builtin implementation of very basic DInterfaces (e.g. working with json). Also, we need to describe the manifest for DeBot. DeBot developer will describe all needed interfaces in this manifest and the DeBot Browser will check it before running DeBot. We need this manifest to keep users secure and private when using DeBot. "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description","content":"Every DeBot must declare which DInterfaces it will use. For this purpose it must have getRequiredInterfaces() function which returns array of required interfaces. Every interface must have an id which is an unsigned 256-bit integer and an address which is used in DeBot as a destination address of internal messages. Address must be a standard Everscale address consisting of DEBOT_WC (equal to 0xDB) as a workchain_id part and interface id as address part (see &quot;Telegram Open Network Blockchain&quot;specification, section 3.1.2 for details about TL-B scheme for address). For example, in solidity getRequiredInterfaces can be implemented like this: // Base contract for all DeBot abstract contract Debot { i32 constant DEBOT_WC = - 31; function getRequiredInterfaces() virtual returns (uint256[] interfaces); } contract DebotA is Debot { function getRequiredInterfaces() override returns (uint256[] interfaces) { return [ID_TERMINAL, ID_MENU, ...]; } }  "},{"title":"How to use DInterface in DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#how-to-use-dinterface-in-debot","content":"To use an interface DeBot should import source file with DInterface declaration and call its methods as any other smart contract methods in Everscale — by sending internal messages to interface address. Before running the DeBot, DeBot Browser should provide callbacks for DEngine to receive all requests to DInterfaces. Requests are packed into internal messages. When Browser receives a message from DEngine it should unpack the message, decode its body, call DInterface function, pack results to internal message and return it to DEngine using Dengine.send(msg). interface BrowserCallbacks { // Message from Debot to Browser with encoded DInterface call send(message: string): Promise&lt;void&gt; // Request from DEngine to approve some action (for example, send mesage to blockchain) approve(action: {}): boolean // Request from DeBot to call another DeBot invoke(debotAddress: string, message: string): Promise&lt;void&gt; }  "},{"title":"DeBot Start​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-start","content":"Befor starting DeBot should also provide metadata, which includes its name, version, authorship information, description, language and ABI. This is accomplished through the getDebotInfo() mandatory function. Along with getRequiredInterfaces() this function is defined in the base contract Debot.sol. // Base contract for all DeBots abstract contract Debot { /// @notice ACTION structure struct Action { // String that describes action step, should be printed to user string desc; // Name of debot function that runs this action string name; // Action type uint8 actionType; // Action attributes. // Syntax: &quot;attr1,attr2,attr3=value,...&quot;. // Example: &quot;instant,fargs=fooFunc,sign=by-user,func=foo&quot; string attrs; // Context to transit to uint8 to; // Action internal data TvmCell misc; } struct Context { uint8 id; // Context ordinal string desc; // message to be printed to the user Action[] actions; // list of actions } string s_dabi; /* * Public debot interface */ /// @notice Returns list of interfaces used by DeBot. function getRequiredInterfaces() public view virtual returns (uint256[] interfaces); /// @notice Used for error handling for external messages if error code &gt;= 400 (TVM) and &lt; 500 (PROCESSING) function getErrorDescription(uint32 error) public pure virtual returns (string desc); /// @notice Invoked by DeBot Browser at debot startup. Returns array of debot contexts. function fetch() public virtual returns (Context[] contexts); /// @notice DeBot entry point. function start() public virtual; /// @notice Returns DeBot metadata. /// @return name String with name of debot, e.g. &quot;DePool&quot;. /// @return version Semver version of debot, that will be converted to string like &quot;x.y.z&quot;. /// @return publisher String with info about who has deployed debot to blokchain, e.g. &quot;TON Labs&quot;. /// @return caption (10-20 ch.) String with short description, e.g. &quot;Work with Smthg&quot;. /// @return author String with name of author of DeBot, e.g. &quot;Ivan Ivanov&quot;. /// @return support Free TON address of author for questions and donations. /// @return hello String with first messsage with DeBot description. /// @return language (ISO-639) String with debot interface language, e.g. &quot;en&quot;. /// @return dabi String with debot ABI. function getDebotInfo() public functionID(0xDEB) view virtual returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ); /// @notice Allow to set debot ABI. Do it before using debot. function setABI(string dabi) public { require(tvm.pubkey() == msg.pubkey(), 100); tvm.accept(); s_dabi = dabi; } /// @notice Returns DeBot ABI. /// @dev Deprecated. Remove later. https://github.com/tonlabs/TON-SDK/blob/dc0631a726295c4e7190361c417214c301ec4e01/ton_client/src/debot/dengine.rs#L175 function getDebotOptions() public view returns ( uint8 options, string debotAbi, string targetAbi, address targetAddr ) { debotAbi = s_dabi; targetAbi = &quot;&quot;; targetAddr = address(0); options = 1; } } contract MyDeBot is Debot { function getErrorDescription(uint32 error) public pure override returns (string desc) { tvm.log(format(&quot;getErrorDescription: {}&quot;, error)); desc = format(&quot;some description about code {}&quot;, error); // TODO description error codes } function fetch() public override returns (Context[] contexts) { tvm.log(&quot;fetch&quot;); // TODO fetch Context } function start() public override { tvm.log(&quot;start&quot;); // TODO start } function getDebotInfo() public functionID(0xDEB) view override returns( string name, string version, string publisher, string caption, string author, address support, string hello, string language, string dabi, bytes icon ) { tvm.log(&quot;getDebotInfo&quot;); name = &quot;MyDeBot&quot;; version = &quot;1.0.0-alpha.0&quot;; publisher = &quot;Everscale&quot;; caption = &quot;My first DeBot&quot;; author = &quot;Everscale&quot;; support = address.makeAddrStd(0, 0x0); hello = &quot;Hello first user!&quot;; language = &quot;en&quot;; dabi = s_dabi; icon = &quot;&quot;; } function getRequiredInterfaces() public view override returns (uint256[] interfaces) { tvm.log(&quot;getRequiredInterfaces&quot;); // TODO add dependency interfaces } }  Run debug log: npx tonos-cli debot --debug fetch &lt;ADDRESS&gt; 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getRequiredInterfaces 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] getDebotInfo 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:43:58 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:43:58 [INFO] fetch DeBot Info: Name : MyDeBot Version: 1.0.0-alpha.0 Author : Everscale Publisher: Everscale Support: 0:0000000000000000000000000000000000000000000000000000000000000000 Description: My first DeBot Hello first user! Run the DeBot (y/n)? y 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getRequiredInterfaces, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getRequiredInterfaces 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotInfo, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] getDebotInfo 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external getDebotOptions, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running getDebotOptions, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external fetch, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running fetch, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] fetch 19:44:02 [DEBUG] (1) ton_client::debot::dengine: switching to 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: switched to ctx 0 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_action: start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: run_debot_external start, args: {} 19:44:02 [DEBUG] (1) ton_client::debot::dengine: running start, addr 0:5225bff6b13f40518f523c18c7af8dcc46a3369845d98cc7df4e36acca5f8490 19:44:02 [INFO] start 19:44:02 [DEBUG] (1) ton_client::debot::dengine: instant_switch = false, state_to = 0 19:44:02 [DEBUG] (1) tonos_cli::debot::callbacks: no more actions, exit loop  Before starting the DeBot, DeBot Browser creates new instance of DEngine with address of DeBot;DEngine downloads DeBot state, queries metadata and list of DInterfaces required by DeBot and returns the list to Browser;Browser must check that it supports all required DInterfaces. If one of interfaces is not supported, Browser must report error to the user (application) and not start the DeBot otherwise Browser must list requested interfaces to user (application);All required interfaces should be approved by user (application);After the list of interfaces is approved, the DeBot Browser starts DeBot using Dengine.start(callback). On every interface call Browser should check permission for DeBot and on success execute it according to isolation requirement if needed. Below you can see DeBot start sequence:  "},{"title":"DInterface specification​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterface-specification","content":"Every DInterface must be discussed and accepted by DeBot Interface Specifications (DIS) Consortium before it can be used in DeBot. All accepted interfaces are published in repo: https://github.com/tonlabs/DeBot-IS-consortium Everybody can suggest new DInterface. Go to repo and follow the instructions. "},{"title":"DInterfaces support in DeBot Browser​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dinterfaces-support-in-debot-browser","content":"DeBot Browser can support and implement any or all DInterfaces published in DIS repo depending on browser's capabilities. For example, console browser cannot support external devices like camera, NFC, microphone and so on. Some interfaces required for basic DeBot operation are built into the DEngine itself (SDK, Hex, JsonDeserialize). They are marked as such in their respective readme files in the IS consortium repository. "},{"title":"DEngine versioning​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#dengine-versioning","content":"DEngine as a SDK module should have a version of SDK itself. DIS statuses: Proposed, Accepted, Published. "},{"title":"Example of DInterface​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#example-of-dinterface","content":"Name\tIDRawInput\t8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 "},{"title":"Description​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#description-1","content":"Allows to get string from user "},{"title":"Functions​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#functions","content":"Function input arguments: answerId: uint32 — function id of result callbackprompt: bytes — string printed to the user and describing what to enter returns: text: bytes — string entered by user "},{"title":"Declaration in Solidity​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-solidity","content":"interface IRawInput { function input(uint32 answerId, string prompt) external returns (string value); } Library RawInput { uint256 constant ID_RAWINPUT = 0x8796536366ee21852db56dccb60bc564598b618c865fc50c8b1ab740bba128e3 // Callback Function Prototype function inputResult(uint32 answerId, string prompt) public { address addr = address.makeAddrStd(DEBOT_WC, ID_RAWINPUT); IRawInput(addr).input(answerId, prompt); } }  "},{"title":"Declaration in C++​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#declaration-in-c","content":"namespace tvm { namespace schema { __interface IRawInput { [[internal, answer_id]] string input(string prompt); };  "},{"title":"Code Example​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#code-example","content":"Solidity​ pragma solidity &gt;=0.6.0; import &quot;Debot.sol&quot;; import &quot;RawInput.sol&quot;; contract ExampleDebot is Debot, RawInput { function start() public { RawInput.input(tvm.functionId(inputResult), &quot;enter your name:&quot;); RawInput.input(tvm.functionId(inputResult), &quot;enter your wallet address:&quot;); } function inputResult(string text) public override { require(text == &quot;Debot&quot;); } }  Note: C++ DeBot are currently in the state of early development, and not all features all completely defined for them yet. "},{"title":"DeBot Special Features​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#debot-special-features","content":"DeBot have 3 special features: calling — get-methods of target smart contracts;calling — external functions of target smart contracts onchain;invoking — other DeBot in a local environment. Ordinary Everscale smart contracts cannot use 1st and 2nd features because they cannot produce external inbound messages. But DeBot can, due to the fact that they are executed in DEngine, that allows DeBot to generate these kinds of messages, send them to blockchain and return results to DeBot. In terms of DeBot, all these features are implemented without DInterfaces but in a native way, like two smart contracts communicating with each other — by sending messages directly to target address. But with only one difference — to call a get-method or call a function onchain DeBot must generate external inbound message, while to invoke another DeBot, it should generate an internal message to the invoked DeBot address. DEngine distinguishes between get-methods and onchain calls by examining the sign header of the message. Signed messages (sign: true) are considered onchain calls, while unsigned messages (sign: false) are considered to be get-method calls. "},{"title":"Get-methods​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#get-methods","content":"Developer Example​ Solidity function showTasks(uint32 index) public view { index = index; optional(uint256) none; ITodo(m_address).getTasks{ abiVer: 2, extMsg: true, sign: false, pubkey: none, time: uint64(now), expire: 0, callbackId: tvm.functionId(showTasks_), onErrorId: tvm.functionId(onError) }(); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If yes, then DEngine analyzes each message by scanning signature and public key bits in message body to understand if message is for get-method call. If bits are zero DEngine downloads target contract and runs its get-method, then returns results to DeBot by calling its function set in the callbackId or onErrorId (in case of errors) headers of message body. "},{"title":"Onchain function call​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#onchain-function-call","content":"Developer example​ Solidity IMsig(m_msigAddress).sendTransaction{ abiVer: 2, extMsg: true, sign: true, pubkey: pubkey, time: uint64(now), expire: 0, callbackId: tvm.functionId(waitBeforeDeploy), onErrorId: tvm.functionId(onErrorRepeatCredit) }(m_address, INITIAL_BALANCE, false, 3, empty); }  Support in DEngine​ DEngine executes DeBot and checks if it produces external inbound messages. If there is one, DEngine analyzes if it is onchain call by scanning signature and public key bits in message body. If signature bit is 1 then DEngine does the following things. Downloads target smart contract, signs the message and emulates its transaction locally;Checks if transaction produces outbound internal messages with funds;Requests permission from DeBot Browser to send this message onchain. Request contains information about funds that will be spent if message will be executed onchain and message itself;If DeBot Browser allows to send message, DEngine sends message to blockchain. "},{"title":"Invoking DeBot​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#invoking-debot","content":"DeBot can call another DeBot by simply sending internal message to it. After DeBot execution DEngine filters all internal messages produced by DeBot with destination addresses with workchain 0. This filter allows to separate DInterface calls (which have 0xDB workchain id) from DeBot invokes. If there are invoke messages, DEngine sends them to Browser through BrowserCallbacks interface. Browser (or user) has to approve the invoke of a new DeBot, at which point Browser creates a new DEngine instance, downloads target DeBot and transfers the message to it. Browsers should generally support a common queue for messages from several DeBot. "},{"title":"Security notes​","type":1,"pageTitle":"DeBot Specifications","url":"learn/decentralization/debot-specifications#security-notes","content":"At start browser creates a DEngine instance, and receives DeBot metadata and list of required DInterfaces through DEngine, and checks them for compatibility and security. When DeBot is running, DEngine proxies all DInterface calls (except calls to builtin interfaces supported by engine itself like SDK calls) directly to Browser which must decide to execute or reject them. Get-method calls are always allowed. Executed by DEngine. External function calls must be approved by Browser. Executed by DEngine. Other DeBot calls are always allowed. But executed by Browser which can block invoke if needed. "},{"title":"End-to-end Decentralization","type":0,"sectionRef":"#","url":"learn/decentralization/end-to-end-decentralization","content":"","keywords":""},{"title":"Background​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#background","content":"Decentralization is an important property of public blockchain technology 1. Despite its claims of decentralization, blockchain keeps on fighting to achieve it through improvements and optimizations mainly related to consensus mechanisms and data exchange protocols. Proof-of-Work and Proof-of-Stake consensus protocols (and their derivatives) have issues related to centralization at both mining/staking and at the front-end levels. Considerable amounts of centralization exist in development ecosystems of some blockchains as well. Decentralization claims can only be made when the whole system is decentralized, and therefore, should be judged by its weakest (or rather most centralized) link. In the current invention we present an end-to-end Decentralization framework (E2ED). In today's blockchains that support smart contracts (or in other words the ability to perform and validate arbitrary computations), user interaction with results of such computations is performed using some front end library (such as Web3 in Ethereum blockchain). The Web3 library takes care of performing blockchain related tasks with blockchain data presented to a user. The IPFS is used to store data in a decentralized manner. Yet as shown below neither is enough to preserve full decentralization of end user interactions with a blockchain system to ensure censorship resistance and security. "},{"title":"Web3​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#web3","content":"Web3.0 js is a collection of libraries which allow you to interact with a local or remote Ethereum node, using a HTTP or IPC connection2. Web3.0 is a collection of JavaScript libraries that allow users to interact with a local or remote Ethereum node using an HTTP or IPC connection. In other words, it’s a kind of SDK which gives users the ability to work with blockchain in the browser. That’s why it actually has a Web in the name and not something else. Web3.0 is numbered 3.0 quite obviously because 2.0 and 1.0 versions of Web already exist, referring to the World Wide Web's evolution where the 2.0 version unlike the 1.0 version, for instance, allows for display of user-generated content, dynamically making websites more sophisticated. Web 3.0 on the other hand is seen as part of the World Wide Web’s evolution due to the fact that it can be considered as a first attempt to access decentralized (blockchain) applications on the web. The purpose of Web3 is to give the ability to create decentralized apps on the web connecting sites to the world of blockchain, in particular Ethereum blockchain. The main problem with this approach is that a user does not really interact with the blockchain when using Web3 based applications, because most of the time the user interacts with many elements of information outside of the blockchain, presented to them by the application user interface. This presents quite a significant problem as all such information and user interface elements are not decentralized, which means they are not immutable, not censorship resistant, and not fault tolerant. Moreover, blockchain related elements that are supposedly temper proofed lose their properties once they are part of this centralized model. "},{"title":"IPFS​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#ipfs","content":"Enters IPFS. The InterPlanetary File System (IPFS) is a protocol and peer-to-peer network for storing and sharing data in a distributed file system. IPFS uses content-addressing to uniquely identify each file in a global namespace connecting all computing devices3. An IPFS developer or user can store the content somewhere that’s always online and accessible and make sure that when the user comes online they know where to find the content. This way we theoretically could use IPFS to store all user interfaces somewhere, save a hash and an address of said content on the blockchain and therefore prove to the user that whatever is displayed in their browser is true and correct by way of verifying it using Web3 library. Yet even an IPFS and Web3 combination does not guarantee end-to-end decentralization as described below in more detail. "},{"title":"User interaction (DeBot)​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#user-interaction-debot","content":"A system is needed to create a comprehensive user experience without relying on trusted infrastructure. To achieve this, we introduced technology for writing the user interface inside the smart contract itself. Decentralized Bot (DeBot) is a technology enabling end-to-end Decentralization at a user interaction level. Using E2ED, any front-end application (be it in a web browser or a purposely built software) can draw an entire user experience without relying on a server. Comparing Web 2.0, Web 3.0 and E2ED based systems (which for the purpose of the diagram below we named Web3.11 as a reminiscent to the famous Windows 3.11), E2ED is not a contradiction to Web3.0 but rather a continuation that closes some centralization loopholes to achieve end-to-end decentralization. Web3.0 itself is not a monolithic system. It has many components such as an IPFS database for storage and others for address discovery and storage query on top. The Web3.0 approach is fragmented. A smart contract is executed in one place and the data it manipulates is stored in another. The data meets the business logic only on an end user device, therefore, the computation performed on such data can not be verified by a blockchain. For that reason we have verifiable business logic (smart contract) operating with the data it can not verify. The only limited verification available is the hash of data stored somewhere else. The interaction with said data is static. If a man-in-the-middle attack is performed on the user device level, the security of Web3 can be compromised. In practice today what happens in almost 100% of cases is shown in the middle column of the diagram below. A user interface is provided by a web server. An application is running on the server and displayed in the user browser (or on a mobile device). The user performs many usual operations with the website content on the server and only when needed to interact with the blockchain does the Web3.0.js get called, which then interacts with the blockchain calling it from the end user device and signed with the user private key. Even if Web3.0 is really advanced and stores the application data (say a website), in the IPFS database the Web3.0.js will be called to perform operations with a blockchain and again not the library nor the smart contract it interacts with, and will not be able to verify what has actually happened to the data that was stored and received from the IPFS on the user device.  In E2ED the smart contract contains the actual user interface in a form of DeBot. The DeBot system described herein is just one way of performing user interface functions by a smart contract. The whole graphical user interface could be drawn if needed. In DeBot the sequence of user actions is performed by calling DeBot smart contract functions using the local virtual machine of any particular blockchain. The result of those actions could at any time be transmitted to the remote smart contract together with the sequence of user performed actions and the whole interface interaction could be verified remotely by the blockchain, including the resulting transaction. In terms of addressing the user, it just needs to know the address of a smart contract DeBot, which is a blockchain address that in turn can be abstracted further using a blockchain based DNS service. "},{"title":"References​","type":1,"pageTitle":"End-to-end Decentralization","url":"learn/decentralization/end-to-end-decentralization#references","content":"The Meaning of Decentralization↩web3.js - Ethereum JavaScript API↩InterPlanetary File System↩ "},{"title":"Bridges","type":0,"sectionRef":"#","url":"learn/everscale-overview/bridges","content":"","keywords":""},{"title":"What is a cross-chain bridge?​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#what-is-a-cross-chain-bridge","content":"Cross-chain bridges was made for transferring assets between chains. Their locks assets in the source chain and creates an equivalent number of wrapped assets in the destination blockchain. When you initiate an asset transfer from one blockchain to another using a bridge, assets are not actually moved or sent anywhere. Instead, the transfer functionality is used in a two-step process and handled by a smart contract. In simple terms - Let's say you want to move tokens from chain A to chain B. What the bridge does is it temporarily locks or freezes your asset in chain A. They then create an equivalent number of new tokens that will be unlocked for you in chain B. When you want to redeem the tokens, that is, when you want to move the original assets back from chain B to the original chain (chain A), the tokens created in chain B will be burned and the original assets will be unlocked. The concept of interchain communication and token transfer is done using a two-way binding system; where the value of a token in either blockchain is the same, as it remains tied to the value of the initial ones. "},{"title":"Everscale Bridges​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#everscale-bridges","content":""},{"title":"Octus Bridge​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#octus-bridge","content":"Octus Bridge is a platform built by the Broxus team that enables cross-chain asset transfers between Everscale and other networks such as Ethereum, BNB Chain, Fantom and Polygon. The platform also implements the Governance interface or DAO, which provides a level of decentralization unprecedented for bridges due to the ability to make decisions directly by network participants, as well as a staking interface. "},{"title":"Adaever​","type":1,"pageTitle":"Bridges","url":"learn/everscale-overview/bridges#adaever","content":"Cross-chain bridge between Cardano and Everscale built by the Broxus team. "},{"title":"Wallets/Exchanges","type":0,"sectionRef":"#","url":"learn/everscale-overview/exchangewallets","content":"","keywords":""},{"title":"Non-custodial wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#non-custodial-wallets","content":"Non-custodial - the user has full control over the keys and their funds. If the private key and the password to recover it are lost, the funds will be irretrievably lost. Combot (Web, Telegram) Koshelek (Android, IOS) Crypterium (IOS, Android) FreeWallet (IOS, Android, Web) Kilox (IOS, Android) "},{"title":"Custodial wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#custodial-wallets","content":"Custodial wallets are similar to bank instruments. The user does not have full control over their funds because an operator (custodian) has access to the private key. Pros: having lost passwords or keys, the user has the opportunity to gain access to the funds again. EVER Wallet (IOS, Android, Web) Ever Surf (IOS, Android, Wundows, MacOS) Everspace (IOS, Android, Telegram) ScaleWallet (Web) Lumi (Android, Web) "},{"title":"Exchange Wallets​","type":1,"pageTitle":"Wallets/Exchanges","url":"learn/everscale-overview/exchangewallets#exchange-wallets","content":"Crypterium (IOS, Android) Koshelek (Android, IOS) "},{"title":"Ecosystem","type":0,"sectionRef":"#","url":"learn/everscale-overview/ecosystem","content":"","keywords":""},{"title":"Wallets​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wallets","content":"Go to the Wallets section to get acquainted with the Everscale network's wallets. "},{"title":"Exchanges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#exchanges","content":""},{"title":"Gate.io (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gateio-everusdt","content":""},{"title":"MEXC (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#mexc-everusdt","content":""},{"title":"Bitrue (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bitrue-everusdt","content":""},{"title":"Digifinex (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#digifinex-everusdt","content":""},{"title":"HitBTC (EVER/USDT, EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#hitbtc-everusdt-everbtc","content":""},{"title":"KUNA (EVER/USDT)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kuna-everusdt","content":""},{"title":"Changelly PRO (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#changelly-pro-everbtc","content":""},{"title":"CEX.io (EVER/USDT, EVER/USD)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#cexio-everusdt-everusd","content":""},{"title":"FMFW.io (EVER/BTC)​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#fmfwio-everbtc","content":""},{"title":"GameFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#gamefi","content":""},{"title":"Pokerton​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#pokerton","content":"Telegram Poker – Win EVER by participating in free daily tournaments. "},{"title":"EverBall.io​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everballio","content":"The world's first game where you mine EVER by absorbing opponents. "},{"title":"Everscale Gaming​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everscale-gaming","content":"Esports tournaments with prize pools in EVER. "},{"title":"EverCraft​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#evercraft","content":"A plugin to connect Everscale with Minecraft. "},{"title":"Galaxy Online​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#galaxy-online","content":"A great MMO with playable blockchain-based races. "},{"title":"Bridges​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#bridges","content":"Go to the Bridges to get acquainted with the Everscale network's bridges. "},{"title":"NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#nft","content":""},{"title":"GrandBaraz​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#grandbaraz","content":"Everscale's first NFT marketplace. Buy, sell, and craft rare digital items. "},{"title":"ChessNFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#chessnft","content":"An NFT platform from the FIDE Chess Federation. "},{"title":"Third Place NFT​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#third-place-nft","content":"An NFT platform from the St. Petersburg creative space Third Place. "},{"title":"Most Expensive​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#most-expensive","content":"Real expensive NFT items! "},{"title":"ScalePunks.com​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#scalepunkscom","content":"A collection of 10,000 unique punks. "},{"title":"DeFi​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#defi","content":""},{"title":"FlatQube​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#flatqube","content":"DEX solution. Easy and fast exchange of tokens and participation in liquidity pools for farming income. "},{"title":"Surf Staking​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-staking","content":"A staking service from the popular Ever Surf. "},{"title":"Surf Depooler​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-depooler","content":"Top depooler rating, performance analysis and depooler selection for more income. "},{"title":"Surf Payments​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#surf-payments","content":"Payments framework built on low-fees Everscale blockchain. "},{"title":"EVER DAO​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-dao","content":"Everscale decentralized project management platform. "},{"title":"EverStart​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everstart","content":"DAO-controlled multi-chain launchpad to connect with curated projects "},{"title":"EverLand​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everland","content":"A P2P secured lending platform with interest on funds. "},{"title":"EverKit Coin​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#everkit-coin","content":"Everscale Coin Information (EVER): stats, wallets, and resources to buy: Exchanges, DEX, and P2P. "},{"title":"KWPC​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#kwpc","content":"The Killer Whale Pod Cast is a launch pad for young blockchain projects developed on the Everscale network. "},{"title":"EVER Pools​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-pools","content":"Depool analysis by Broxus – the developer of FlatQube and Octus Bridge. "},{"title":"Ever Live​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-live","content":"Everscale Blockchain Explorer by EverX. "},{"title":"EVER Scan​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#ever-scan","content":"Everscale Blockchain Explorer by Broxus. "},{"title":"Wrapped EVER​","type":1,"pageTitle":"Ecosystem","url":"learn/everscale-overview/ecosystem#wrapped-ever","content":"WEVER is Wrapped EVER. Similar to Wrapped Ether but for Everscale. "},{"title":"Introduction","type":0,"sectionRef":"#","url":"learn/everscale-overview/introduction","content":"Introduction Everscale community is happy to see you one more member of the network. Please specify who are you and what are you looking for in Everscale network: We believe that the most popular roles of Everscale blockchain participants are: Individuals - users who want to farm, hodl, contribute or iteract another way with products in Everscale ecosystem.Institutionals - users who want to invest in network or need some institutionals features like multisig to work with network protocols or just hodl.Developer - want to build anything in Everscale.Validator - want to secure the network ledger and earn EVER.Partner - want to integrate Everscale network or EVER token in your project. WelcomeUsersInstitutionalsDevelopersValidatorsContributors","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"learn/faq","content":"FAQ","keywords":""},{"title":"Governance","type":0,"sectionRef":"#","url":"learn/governance","content":"Governance","keywords":""},{"title":"Support","type":0,"sectionRef":"#","url":"learn/support","content":"Support","keywords":""},{"title":"Terminology","type":0,"sectionRef":"#","url":"learn/terminology","content":"Terminology","keywords":""},{"title":"History","type":0,"sectionRef":"#","url":"learn/history","content":"","keywords":""},{"title":"History behind TON blockchain​","type":1,"pageTitle":"History","url":"learn/history#history-behind-ton-blockchain","content":"The Telegram messenger project was created by brothers Nikolay and Pavel Durov in 2013. Nikolay Durov invented the MTProto encryption scheme, which formed the basis of the project. The main concept of Telegram messenger was privacy and secure communication of users. The messenger existed on Pavel Durov's personal funds until 2017. In 2017, Pavel Durov develops the concept of TON - Telegram Open Network. The Telegram Open Network project is inextricably linked with the Telegram Messenger, with plans to integrate the Gram cryptocurrency [1]. In February 2018, Pavel Durov is raising $850 million in investments in the first round of ICO for the development of blockchain platform TON (price of the Gram token was $0.38). The ICO notification is officially registered by the US Securities and Exchange Commission (SEC). From the business plan of Pavel Durov, it follows that Telegram as a messenger is the first phase of a more global project, and was created mainly to form a huge customer base. As TON develops, the messenger itself will become just one of its applications, so in 2021 it is planned to rebrand Telegram Open Network into The Open Network, and the Telegram brand will remain with the messenger. The real goal of the project is the Telegram Open Network platform, which offers Gram cryptocurrency with fast transaction speeds, as well as various services from Proxy for bypassing censorship to bots and file storage that can be paid for with Gram cryptocurrency. In the second round of ICO, an additional $850 million are raised(price of the Gram is up to $1.33)[2]. At the same time, Pavel Durov rejected about half of the applications for investment until the third round of placement - investors wanted to invest more than $3.7 billion in the project. Pavel Durov's refusal to receive new investments is justified by the fact that his plan to raise money exceeded his expectations many times. The cost of establishing the Telegram Open Network is estimated at $400 million. At the same time, the total amount of raised investments amounted to $1.7 billion for both rounds. The whole amount was received from private investors who got Gram tokens in return for their investments. The list of investors includes quite famous personalities: Roman Arkadievich Abramovich (entrepreneur, included in the list of Forbes, invested $10 million through the fund Norma Investments Limited), David Mikhailovich Yakobashvili (founder of the company Wimm-Bill-Dann, invested $10 million), Sergey Alexandrovich Solonin (founder of the platform Qiwi, invested $ 17 million), Mikhail Safarbekovich Gutseriev (main shareholder of the group Safmar, the owner of the company M.Video and Eldorado, invested $15 million through Larnabel Ventures) [3]. TON blockchain platform was launched in autumn 2018. The developers then said that the network is 70% ready and most of the components have already been finalized. The launch of testnet should have taken place in January 2019, however, was postponed. On September 6, 2019, TON test portal for developers with official project specifications was opened - https://test.ton.org/, and on https://test.ton.org/testnet/ TON network explorer was available, displaying the first hundreds of working nodes of the network. The New York Times, commenting on these events, noted that the project produces test tokens ahead of schedule, which should satisfy investors. Observers, referring to experts in crypto, also note that Durov's strategy to keep the development of TON in relative secrecy has given rise to some skepticism in the cryptographic society about the competing Libra cryptocurrency project from Facebook, but in the end, it turned out to be correct, because Facebook, after making the development of Libra transparent, immediately incurred the anger of regulators. At the same time, crypto experts such as David Gerard note that despite the TON team's efforts to meet the KYC-AML principles, the project's central risk is similar to Libra - government regulators may be afraid of losing control of the financial system [4]. In October 2019, the U.S. Securities and Exchange Commission (SEC) demanded a ban on the issuance of Gram. The SEC, in its report, recognized Gram as security (not a commodity or utility token) and the Gram issue itself violated securities laws. On January 7 and 8, 2020, the SEC interrogated Pavel Durov about TON ICO. The interrogation took place in Dubai, UAE. The American regulator was trying to find out why Durov launched the ICO, how much money he spent on Telegram and TON, and why Gram token is not a security. Durov replied that the money was needed to buy equipment and maintain the blockchain platform, and Gram was a utility token, not a security. On March 25, Telegram challenged the U.S. court ban on transferring Gram tokens to investors. The court of the Southern District of New York State in a preliminary decision agreed with the SEC's opinion that the project's cryptocurrency is a security. The U.S. authorities claim that investors purchased coins to sell on the secondary market to earn money. On May 12, 2020, Pavel Durov announced in his Telegram channel that he has closed the TON blockchain project. According to Pavel Durov, Telegram's participation in TON development is over. He urged users not to trust money or data to projects that use the name of the messenger or platform. No one from the company team participates in any of these projects, Durov said. He added that networks that use TON's developments may appear, but Telegram has nothing to do with them and is unlikely to ever support them. On Thursday, May 7th, the Free TON Community (consisting of developers and potential TON users) launched the Free TON blockchain platform. Instead of Gram participants will get tokens called TON Crystal. To become a community member you need to sign Free TON Declaration of Decentralization. Source: Everscale Wiki "},{"title":"Contributors","type":0,"sectionRef":"#","url":"learn/tutorial/contributors","content":"Contributors","keywords":""},{"title":"Developers","type":0,"sectionRef":"#","url":"learn/tutorial/developers","content":"Developers","keywords":""},{"title":"Users","type":0,"sectionRef":"#","url":"learn/tutorial/users","content":"","keywords":""},{"title":"Buy and store tokens​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#buy-and-store-tokens","content":"Everscale has several types of tokens, the most popular of which is the TIP-3 token format. The main network token is EVER. It is used to pay fees to validators, reward stakeholders and participants in contests run by the DAO management team, and performs a number of other important functions within the network. In order to store and manage tokens on the Everscale network, you will need a wallet that supports the TIP-3 token format. There are many different ways to buy EVER: Exchange walletsExchangesDEXS Check out the Wallets section for the most popular token storage solutions. "},{"title":"Popular cases of interaction with Everscale​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#popular-cases-of-interaction-with-everscale","content":"Once you have an Everscale network wallet, you can start interacting with various products (Dapps) of the network. Everscale provides many earning opportunities for regular users. You can earn on farming, NFT, staking or trading on exchanges and DEX. In the Ecosystem section, you can get acquainted with the most popular representatives of Everscale dapps in various industries: DeFi, NFT, GameFi, etc. "},{"title":"Community​","type":1,"pageTitle":"Users","url":"learn/tutorial/users#community","content":"Everscale can be proud of its community - a community of friendly newbies and experienced users: network members help each other and discuss various aspects of the network in chats and on the Everscale forum. Go to the main Everscale chats and groups to see the strength of our unity: Everscale Community Everscale News EverKit Everscale DeFi Everscale Dev "},{"title":"Multisig","type":0,"sectionRef":"#","url":"learn/tutorial/institutionals/multisig","content":"","keywords":""},{"title":"What is multisignature wallet?​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#what-is-multisignature-wallet","content":"As a simple analogy, we can imagine a secure deposit box that has two locks and two keys. One key is held by Alice and the other one is held by Bob. The only way they can open the box is by providing their both keys at the same time, so one cannot open the box without the consent of the other. Basically speaking, the funds stored on a multi-signature address can only be accessed by using 2 or more signatures. Therefore, the use of a multisig wallet enables users to create an additional layer of security to their funds. "},{"title":"Use cases for a multisignature wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#use-cases-for-a-multisignature-wallet","content":""},{"title":"Increasing security​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#increasing-security","content":"By using a multisig wallet, users are able to prevent the problems caused by the loss or theft of a private key. So even if one of the keys is compromised, the funds are still safe. Imagine that Alice creates a 2-of-3 multisig address and then stores each private key into a different place or device (e.g. mobile phone, laptop, and tablet). Even if her mobile device is stolen, the thief won’t be able to access her funds using only 1 of the 3 keys. Similarly, phishing attacks and malware infections are less likely to succeed because the hacker would most likely have access to a single device and key. Malicious attacks aside, if Alice loses one of her private keys, she can still access her funds using the other 2 keys. "},{"title":"Two-factor authentication​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#two-factor-authentication","content":"By creating a multisig wallet that requires two keys, Alice is able to create a two-factor authentication mechanism to access her funds. For instance, she could have one private key stored in her laptop and the other one in her mobile device (or even on a piece of paper). This would ensure that only someone who has access to both keys is able to make a transaction. Keep in mind, however, that using multisig technology as two-factor authentication can be dangerous – especially if it is set as a 2-of-2 multisig address. If one of the keys are lost, you won’t be able to access your funds. "},{"title":"Escrow transactions​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#escrow-transactions","content":"Creating a 2-of-3 multisig wallet can allow for an escrow transaction between two parties (Alice and Bob) that includes a third party (Charlie) as a mutually trusted arbiter in case anything goes wrong. Charlie, the arbiter, would only need to step in if there was a dispute, at which point he could use his key to create a signature that would be provided to either Alice or Bob, according to Charlie’s judgment. "},{"title":"Decision making​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#decision-making","content":"A board of directors might use a multisig wallet to control access to a company’s funds. For example, by setting up a 4-of-6 wallet where each board member holds one key, no individual board member is able to misuse the funds. Therefore, only decisions that are agreed upon by the majority can be executed. "},{"title":"Everscale multisignature wallets​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#everscale-multisignature-wallets","content":"Let's move on to choosing a multi-signature wallet. "},{"title":"EVER Wallet​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-wallet","content":"Everscale native wallet created by the Broxus team. Access on IOS, Android and as a Google Chrome browser extension. It has several types of multisignature wallets, including those with the ability to add new custodians. A distinctive feature of the wallet is the ability to connect it with Everscale's most popular DeFi products: FlatQube (DEX), Octus Bridge, Everstart (launchpad), etc. Download link "},{"title":"Ever Sufr​","type":1,"pageTitle":"Multisig","url":"learn/tutorial/institutionals/multisig#ever-sufr","content":"One of the most popular Everscale wallets. Available on IOS, Android, Windows and MacOS. Provides the ability to create a multisig wallet and add up to 32 custodians. Download link "},{"title":"Validators","type":0,"sectionRef":"#","url":"learn/tutorial/validators","content":"Validators","keywords":""},{"title":"TVM","type":0,"sectionRef":"#","url":"learn/tvm","content":"TVM","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"learn/welcome","content":"","keywords":""},{"title":"About Everscale​","type":1,"pageTitle":"Welcome","url":"learn/welcome#about-everscale","content":""},{"title":"What is Everscale?​","type":1,"pageTitle":"Welcome","url":"learn/welcome#what-is-everscale","content":"Everscale is a fast, secure and scalable blockchain and network project capable of processing up to a million transactions per second thanks to its unique dynamic technology. "},{"title":"History​","type":1,"pageTitle":"Welcome","url":"learn/welcome#history","content":"Ton Development (2017-2019) Brothers Pavel and Nikolai Durov and the Telegram team develop the TON (The Open Network) project. The company TON Labs (now EverX) develops TON OS. TON closing (2020) The US Securities and Exchange Commission (SEC) prohibits the issue of Gram tokens (TON currency). Pavel Durov announces the closure of the project. Free TON launch (May 7, 2020) The community (consisting of TON developers and potential users, including TON Labs) launches the Free TON blockchain platform with its native currency TON Crystal. Everscale (2021) A decentralized decision was made at the end of 2021 to rebrand Free TON to Everscale, and the ticker name from TON to EVER. The innovative TON architecture is the foundation of Everscale. However, Everscale is already much more than just TON. Our community has two years of hard work behind it. "},{"title":"Benefits​","type":1,"pageTitle":"Welcome","url":"learn/welcome#benefits","content":"Fast Everscale has the fastest speed of any blockchain. The blockchain architecture makes it possible to process up to a million transactions per second. Safe With advanced end-to-end encryption, Everscale offers multiple layers of security for sensitive information despite an open, transparent data pool for all transactions. Innovative Everscale introduces some new and unique features such as dynamic multithreading, soft majority consensus, and distributed programming. Decentralized Everscale is run by a decentralized community based on meritocratic principles through a soft majority protocol. "},{"title":"Features​","type":1,"pageTitle":"Welcome","url":"learn/welcome#features","content":"Smart contracts A smart contract is a program that is stored and executed on a blockchain. The results of smart contracts are verified and confirmed by many network nodes, which ensures end-to-end decentralization, as well as resistance of calculations to errors and malicious attacks. On the Everscale network, the implementation of smart contracts is conceived to be universal. As a result, all wallets and the implementation of any additional logic as a whole involve smart contracts, unlike in many other blockchains of previous generations. In addition, all interactions between smart contracts are asynchronous (unlike, for example, in Ethereum), which is necessary to scale network performance. An important property of the Everscale network is that any network action to process a smart contract burns a small amount of tokens, which protects against abuse and DDoS attacks. It quickly becomes very expensive and unprofitable to create a sufficiently high load for DDoS attack. Staking We can understand staking as receiving passive income through storing cryptocoins. This process uses the Proof of Stake (PoS) algorithm – proof of share of ownership. PoS is one of the methods to protect the blockchain from interference and inaccuracy of the data placed. Staking is kind of an alternative to traditional mining. Cheap transactions The wallet-to-wallet transaction fee is currently around 0.012 EVER. Farming Farming is the process of earning tokens as a reward for providing liquidity to a project by placing a specific pair of tokens in a pool. Grants Everscale Grants is a campaign designed to attract promising IT projects that can contribute to the development of the Everscale ecosystem. Validators Validators are the nodes in the blockchain system that have the task of keeping the network running. A validator is a set of software. A person or team simply runs, configures, and controls it. TIP-3 Tokens TIP-3 Token is an Everscale token standard that describes the basic principles for building token smart contracts. The current version is TIP-3.1 DePools A DePool (depool) is a smart contract that allows users to combine deposits of different network users to form blocks by validators. A DePool is required if a node that wants to become a validator does not have enough of its own funds for a stake. With this smart contract, users transfer (invest) their stakes into a common pool, for which they receive a reward depending on the amount deposited after each validation cycle. Bridge A blockchain bridge is a link that provides communication and interaction between two blockchains. Thanks to such bridges, any data, information, and tokens can be transferred between two blockchain platforms. Swap A token swap is a process in which one cryptocurrency is exchanged for another at a predetermined rate. NFT NFTs are a &quot;hot&quot; trend in the cryptocurrency world. Issuing NFTs through Everscale is beneficial not only because the network has very fast and cheap transactions. The process of issuing and exchanging NFTs has become even easier with the release of True NFT technology, which has made it possible to place all NFT data (including content) in the blockchain, look up records of collections and tokens, and actually transfer tokens from one address to another like ordinary coins. "},{"title":"Decentralization​","type":1,"pageTitle":"Welcome","url":"learn/welcome#decentralization","content":"Special attention should be paid to decentralization in Everscale’s management How can we manage a blockchain project in a decentralized way? In Everscale, anyone can influence the project’s development. We use a public forum to discuss important decisions. We have also formed certain devices in the project that help make important decisions using the soft mechanism Majority Voting. Let's take a look at the tools we've created for governance. Main Governance The chief task of members of the main governance is to sign transactions for issuing funds from providers (more than 50% of signatures are required). Members of the main governance are sometimes called initial members. EVER DAO EVER DAO is a decentralized governance platform that allows EVER (WEVER) token holders to vote on proposals concerning the Everscale network. Community members can express their will and opinion on significant network events in a transparent and verifiable way. Subgovernances Subgovernances are groups of people, each of which is responsible for a certain type of activity. Members of subgovernances receive coins for Everscale’s development (for example, by organizing contests) DeFi Alliance This is an association of companies that creates the necessary infrastructure to attract teams and projects, raise liquidity from other projects in Everscale, and create partnerships with large companies with large amounts of liquidity. "},{"title":"Tokens​","type":1,"pageTitle":"Welcome","url":"learn/welcome#tokens","content":"EVER Everscale currency ticker. A short name that is used in wallets, exchanges, etc. The currency is used to pay for gas (transaction fees) and fees to validators, as well as reward stakeholders and contest participants. It also performs a number of other important functions within the network. Everscale also has a technological solution known as TIP3 – the ability to create your own tokens (similar to Ethereum ERC20) Next, we'll look at where to buy and store EVER, as well as where and how to earn. Where and how to buy EVER Now let's talk about the most popular and convenient ways to buy: Dex exchanges:​ FlatQube Bank card​ EXPi Ever Surf Crypterium Exchanges​ Gate.io MEXC Global Changelly PRO P2P (hand to hand)​ Koshelek Wallet BuyTIP3 BOT Where to store EVER​ Wallets section "},{"title":"Earn​","type":1,"pageTitle":"Welcome","url":"learn/welcome#earn","content":"Validators Become a network validator and earn through validation. (Average 6% per year) Validators Staking Provide your EVER to pools using staking services. (Average 6% per year) Staking Farming Make money from income farming by lending your EVER to DEX liquidity pools. (Up to 150% per year (but there are risks). Farming Grants Get financial and technical support to develop your own projects in the Everscale network. (Individually, depending on the project.) Hackaton&amp;Grants "},{"title":"Ecosystem​","type":1,"pageTitle":"Welcome","url":"learn/welcome#ecosystem","content":"The Everscale ecosystem is made up of blockchain-based projects. These are primarily decentralized finance DeFi, GameFi, NFT, dApps. Anyone can develop their own project and become part of the Everscale ecosystem. "},{"title":"Free Software License (TIP-1.1)","type":0,"sectionRef":"#","url":"standard/TIP-1.1","content":"","keywords":""},{"title":"Introduction​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#introduction","content":"Many members of our community have asked questions about Free TON code philosophy. Why we call it Free Software? What is a relationship between Free TON and Free Software? What is the difference between Free Software and Open Source? I have decided to combine this with an idea I have regarding gas payment redistribution in TON. You will see below why it is related. The concept of Free Software predates open source. Richard Stallman has started the free-software movement in 1983 with a launch of GNU Project while open-source movement has been derived from Free Software only in 1998. To clarify, the Free Software is not in conflict with Open Source. As explained below it follows all the same principles and the differences seems more ideological. Yet TON project did not have any problem with open-source nature of it software. It is all open sourced. The problem was exactly about the Freedom of people to use it. That is why Free TON is heavily influenced by Free Software movement. Declaration of Decentralisation is, in many ways, inspired by Stallman’s «The GNU Manifesto»1. In «Why Open Source misses the point of Free Software» Stallman writes among other things: «The terms «free software» and «open source» stand for almost the same range of programs. However, they say different things about those programs, based on different values. The free software movement campaigns for freedom for the users of computing; it is a movement for freedom and justice. By contrast, the open source idea values mainly practical advantage and does not campaign for principles. This is why we do not agree with open source, and do not use that term»2. It seems Free TON is in agreement with this line of thought. While all our software is open source it is the Freedom to run the software what has launched this network. Now let’s talk about Copyright and Licensing as they relate to the Free Software in general and Blockchain in particular. Before we start I need to say that blockchain may potentially provide a solution to some of the free software inherited business model problems. We all remember that free in the free software stands for freedom and not for zero price. The ability to get paid for a software should not be based on restrictions imposed by its license. But what it should be based upon then? There are several business models for free software non of which really works. What works is a business model that is not exactly related to the software itself and therefore can not be attributed to it. Such as charging for support or for portions of the software which are closed source. It all seems quite unnatural. It also prevents one of the major points of free software — an open collaboration of the community around software projects. Donald Fischer article title «Open source creators: Red Hat got $34 billion and you got $0. Here’s why»3 is self explanatory. IBM has bought a commercial company that was built on top of many developers’ contribution to its code. Those developers never got any part out of the value they have created. "},{"title":"Aligning the incentives​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#aligning-the-incentives","content":"Many free and open source software projects struggle to introduce a sustainable business model. This is one of the reasons why most of the open source software contributors work for large corporations. When a venture capital provides funding to a software project it expects multiple return on its capital. With commercial software it is quite straight forward — a company is charging money for its software use and if successful passes profits to its stakeholders. With free software its quite difficult. That is why there are very few (or should we say: not enough) commercially successful open source software companies. Blockchain introduces a unique opportunity for Free Software developers to align their commercial interests with those of users for the benefit of the whole ecosystem. As an Internet of Value protocol, Blockchain has built-in network incentive mechanism — network fees (or gas). To remind: Miners in Proof-Of-Work collect miner rewards and network fees to compensate them for resources spent to secure the network and process transactions. Both security computations and transaction processing are separate resources, thus requiring separate fees. In Proof-Of-Stake Validators commit funds and processing power to secure the network and process transactions (in a form of smart contract execution in TON). For this they also get separate rewards: block rewards in a form of token emission and transaction reward in a form of a fee. Please note, rewards are separated in both cases. We propose to extend the reward model to transaction facilitators. It would be logical to pay part of the fees to the smart contract developer who is initiating the transaction which pays the fee. This will attract both Developers and Users which will increase network usage and total transaction fees for all network participants. "},{"title":"On-chain licensing fees​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#on-chain-licensing-fees","content":"Somewhat naive mechanism but with the same underlying idea is proposed by Near blockchain. «The developerReward are allocated by per block per account, as they can be efficiently done every time the transaction or receipts is being processed by the contract»4. The problem with this approach lays in the fact that network fees not only pays for resources but also provide an important anti spam mechanism. One can use the developer kick-back to simply lower an attack costs. To mitigate that risk we propose a use of a special Payout Contract. This contract is going to pay the collected Copyleft fees to developers only after certain threshold in both amount of fees and time frame are surpassed. In this respect the Developer motivation is again aligned with the Network security model — it is not practical to break the network where one receives a long term rent. "},{"title":"Some technical details​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#some-technical-details","content":"Technically we introduce a TVM Opcode FB0A. Contract may include that code together with a License information and address of its developer. Collator will include a reward related to gas fees from these transactions into the block for the address indicated in the TVM instruction in the amount corresponding to the indicated License. The percentage of gas fees depends on the license type such as that the most free software compatible license provides more gas. FB0A - COPYLEFT (n x y - ), looks up for the license rule for ‘n’ in ConfigParam (for example 42) and creates output action to send part of the tokens it collected from gas fees to Payout contract indicated in ConfigParam for address x:y, where x - is 32 bit signed integer for workchain and y is 256 bit unsigned integer for contract address in this workchain. It will not throw any exceptions if n or the address are incorrect. Generally allowed licenses are those supported by Free Software Foundation as described here: https://www.gnu.org/licenses/license-list.html#SoftwareLicenses 2 License types payout GPL-Compatible Free Software Licenses 2 → 30% fees GPL-Incompatible Free Software Licenses → 20% fees To implement we add network config parameter: license fees threshold value Collator check threshold each time the instruction is executed. After threshold is reached collator sends value to Developer Account defined in contract instruction FB0A TVM creates special out action with Developer Account (last call of FB0A matters) If account is been deleted, the executor sends value to Developer Account or to ValueFlow if it is not enough (this case must be checked in Validator) Executor analyzes special out action and counts value then sends message to developer account (payment for transaction gets from value) We add fields to json objects and QServer for SDK Collator and Validator must check fees from ValueFlow with Developer correction "},{"title":"Copyright discussion​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#copyright-discussion","content":"«What is the proper way to decide copyright policy? If copyright is a bargain made on behalf of the public, it should serve the public interest above all. The government’s duty when selling the public’s freedom is to sell only what it must, and sell it as dearly as possible. At the very least, we should pare back the extent of copyright as much as possible while maintaining a comparable level of publication»5. One important dimension of copyright is its durationAnother dimension of copyright policy is the extent of fair use: some ways of reproducing all or part of a published work that are legally permitted even though it is copyrighted. (c) Richard Stallman Both duration and fair use of copyright is balanced in this proposal by virtue of compensating copyright holder by Payout Contract creating an ongoing reward from the network while at the same time not preventing a forking possibility by other developers who then need to improve the software in a way that will bring new users and create new intensive for the new contributor. So both improvements as well as long term rent (subscription) is provided for developers. The Copyleft spirit is fully supported here as the Fee is collected for developers who facilitates the fees creation in the first place. The freedom to fork is fully executed as well as anyone can fork the code of a smart contract. In the end it is the community of users who chooses which contract to use and the decision is usually based upon the reputation of the code represented by the hash of the code where is no single byte has been changed. Therefore the system is merit-based. Both long term developer’s incentives for original developers and forking is provided. To recap the proposed system is compatible with all four essential freedoms: The freedom to run the program as you wish, for any purpose (freedom 0).The freedom to study how the program works, and change it so it does your computing as you wish (freedom 1). Access to the source code is a precondition for this.The freedom to redistribute copies so you can help others (freedom 2).The freedom to distribute copies of your modified versions to others (freedom 3). By doing this you can give the whole community a chance to benefit from your changes. Access to the source code is a precondition for this. "},{"title":"References​","type":1,"pageTitle":"Free Software License (TIP-1.1)","url":"standard/TIP-1.1#references","content":"The GNU Manifesto↩Why Open Source Misses the Point of Free Software↩Open source creators: Red Hat got $34 billion and you got $0. Here's why↩Economics in a Sharded Blockchain — Section 06 — Developer Business Models↩Misinterpreting Copyright — A Series of Errors↩ "},{"title":"DeCert — Decentralized Certificates","type":0,"sectionRef":"#","url":"standard/TIP-2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#abstract","content":"There is a clear need for unified decentralized and distributed certificate system in Free TON. As described in more details below, such system would be used in providing many services which requires a certified provable key-value store. For example a Decentralized Name Service (DeNS), a Prove of Ownership / Prove of Purchase certificate and many others. Current solutions (for example a TON DNS, proposed here) are either a large smart contracts which maintains a full list of records, or a tree-like solutions which shards the list based on some parameters. Neither of these solutions are satisfactory due to a lack of scalability, high costs of maintenance, long search time, single point of failure and so on. Here I present a completely distributed system, which does not require centralized record, nor a tree of domains or records with almost zero latency. The design relies heavily onе the principles of TIP-3 Token architecture with some notable modifications. "},{"title":"Issuance​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#issuance","content":"Root is a smart contract contains a Code of Certificate smart contract without data. The Root has methods for Certificate Issuance, Certificate Code Retrieval, Root PubKey retrieval and Version history. Each Certificate can become a Root, therefore a Root smart contract and its Certificate smart contract are the same. The Code contains an address of its Root. When a User wishes to register it is calling a Certificate Issuance method in Root, sending a Certificate Data (for example an alphanumeric string of a certificate body). Root is taking its Public Key and a Code of Certificate smart contract, inserts a Certificate Data sent by a User, calculates the address of Certificate and checks if the address already has a Certificate or any other Code deployed by sending a bounced true message calling getData method. If a contract exists it means that a Certificate with the same Certificate Data already exists. The contract then can return a registration information to the Root which will return it to a User. If a contract does not exist the message will bounce to the Root smart contract which will mean the Certificate can be registered. If Certificate does not exist the Root will Issue the Certificate by deploying the Certificate Contract with its Data. On deploy the Certificate will check that it has been deployed from the root address by comparing the address of a Root inside with the deployer address. If there is no match the deploy will fail. Of course additional business logic steps could be included between the last two steps, such as monetization or other mechanics as shown below in one of the examples. "},{"title":"Resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#resolving","content":"To resolve the Name any User can now call Get method Resolve of a Root locally to obtain an Address. Root will use Certificate Code, Root PubKey, insert a name User wishes to resolve into Certificate Code and calculate the address. To resolve a Root smart contract one can take any Certificate Core and resolve for the Root name. A user application can cash the Certificate Code smart contract and Root PubKey once, after which resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. The Certificate itself contains variable types of addresses of a target smart contracts to which the Certificate owner wishes the name to point. A user should choose which type of address they wish to use. "},{"title":"Reverse resolving​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reverse-resolving","content":"In order to make a reverse resolving a smart contract need to state its certificate address. The user will check if certificate indeed has contract address. "},{"title":"Search​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#search","content":"Of course search is one of the most important features of any name system. Knowing a Certificate Code hash enables to retrieve all smart contracts having the same hash by simply querying the blockchain state. Decoding contract data will produce a full list of names under specific Root. It would be quite easy to produce a table with all the certificate records. "},{"title":"Example: Decentralized Name Service (DeNS)​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-decentralized-name-service-dens","content":"Let’s consider a DeNS Root is a smart contract which contains a Code of the Name Identity Certificate (NIC) smart contract. The Root has methods for Identity Registering, NIC Code Retrieval, Root PubKey retrieval, Version history. When a User wishes to register an Identity it is calling a «RegName» method in DeNS Root with the signed message of UTF-8 string (Name) together with a Registration Bid (a hash of a Bid Value in TONs with some salt) with value attached 1 TON. DeNS Root is taking its Public Key and a NIC Code inserts a Name, calculates the NIC address and checks if the address already has a NIC Code deployed by sending a bounced true message calling method «getName». Return to User a Whois Information. If it bounces or a registration period in Whois is less than 28 days DeNS Root will send the name into an Auction Smart Contract together with a Registration Bid Hash and a number of years before expiration. First bidder determines the duration of the auctioned name. Other users will be able to Bid for the same name but only for same duration with their Bids following exactly the same process. Auction duration is minimum 7 days per year of name duration but no more than 28 days. At the end of the Auction all participants will submit to the Auction contract a message signed from the address of the original bid together with their original bid price and salt. The winner of the auction will be determined by the highest bid per day and will pay the second higher price for the Name Certificate. Once DeNS Root knows the Auction result it will wait until registration period ends if the name certificate has existed before or immediately deploy the NIC smart contract into the address calculated as a NIC Contract Code with a Name inserted into initial data and PubKey of the Owner passed in its constructor. To resolve the Name any User can now call Get method «Resolve» of DeNS Root locally to obtain an Address. DeNS Root will use Code of NIC smart contract, a DeNS Root PubKey, insert any name they are wishing to resolve into NIC Code and calculate the address. Since most of the time a user application will just cash the Code of NIC smart contract and DeNS PubKey, resolving any name is achieved locally with a simple address calculation, with no need for network connection at all. "},{"title":"Example of NIC smart contract methods​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-of-nic-smart-contract-methods","content":"Whois — sends all certificate data: a name, date of registration, owner PubKey GetWhois is a whois getter GetAddress by Type, for example — ADNL, Wallet, RegName GetResolve ChangeAddress ChangeOwnership "},{"title":"Free TON Name Identity Certificate convention​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#free-ton-name-identity-certificate-convention","content":"Format: any alfa-numeric string except for a dot (.) and slash (/) which are prohibited. Only top level names are provided by DeNS Root, but any NIC smart contract can point into a next level of hierarchy which is divided by / top-name/sub-name/ The dot (.) is specifically prohibited as to not create confusions with a current internet domain system. "},{"title":"Example: Ownership Certificate​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#example-ownership-certificate","content":"The Certificate is issued by Root for ownership of an item. Let’s call it certificate of Ownership or COW for short. COW will include a serial number of an item a User want to prove owning. Since the PubKey of an owner of certificate is presented it is easy to prove an ownership of an Item by finding the certificate with corresponding serial number calculating the address of this certificate with this number, POW Code and Root PubKey without a need to maintain any centralized ledger of said items. The transfer of ownership of an Item is easily supported as well by calling a ChangeOwnership Method in the POW signed by the owner private key. "},{"title":"Reference​","type":1,"pageTitle":"DeCert — Decentralized Certificates","url":"standard/TIP-2#reference","content":"Contest Proposal: Decentralized Name Service (DeNS)ReDeNS — Reverse DeCert (TIP-2.1) "},{"title":"ReDeNS — Reverse DeCert (TIP-2.1)","type":0,"sectionRef":"#","url":"standard/TIP-2.1","content":"ReDeNS — Reverse DeCert (TIP-2.1) In TIP-2 it is stated that in order to resolve a Certificate Address from the Contract Address, that contract must have its Certificate Address explicitly stated. There is a need sometimes to resolve some certificate address from the address of a contract. Here we present an architecture and implementation of Reverse DeCert and one of its usecases: ReDeNS Reverse Decentralized Names or ReDeNS for short is a certificate that enables reverse resolving of some contracts addresses from another contract. It uses a contract Placeholder for each type of contract functionality that we want to be able to put into external (or satellite) contract of a main contract. ReDeNs enables any client to calculate the address of a satellite contract using a ReDeNs code as a certificate for each type of satellite contract it desires to resolve. In order to resolve a ReDeNS address the user may calculate an address taking a hash of a main contract and a hash of ReDeNS certificate as initial data and an owner address or PubKey in constructor parameters. After the deploy of initial ReDeNS certificate code developer will use SetCode to change the ReDeNS certificate code to desired type of satellite smart contract (with ABI, Getter or DeBot functionality, respectively and so on) For example we have identified 3 types of satellite contracts which will be default ReDeNS Certificates of any main contract in Solidity and C++ Compilers and TON OS SDK: ABI, GETTERS and DEBOT. To protect contracts without ReDeNS certificate deployed from squatters we propose to use header with bitmask: one bit for each type of ReDeNS certificates: abi-DeCert, getters-DeCert, debot-DeCert and so on. So far, we decided to have 16-bit bitmask. 3 of them already occupied. { Abi, getters, debot }. The ReDeNS certificate code is as following: How to create DeBot derived from your smart contract","keywords":""},{"title":"Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-3","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#abstract","content":"The following standard describes the basic idea about distributed fungible token architecture. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#motivation","content":"The suggested standard differs considerably from Ethereum ERC20 and other smart contract token standards with single registry due to its distributed nature related to Everscale blockchain particularities. Given that Everscale has a storage fee, using an existing ERC20 standard design would cause excessive maintenance costs. Also, ERC20 is somewhat incompatible with the sharding architecture. Therefore, a Distributed Token standard is preferable. The ERC20 sharding implementation (with an idea to simply shard its registry) has drawbacks mainly related to complicated and expansive management. TIP-3 is fully distributed and implies separate storage of each user’s balance. "},{"title":"Architecture​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#architecture","content":"General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-root","content":"Token root contract stores the general information about the token, e.g. name, symbol, decimals, token wallet code and so on. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#token-wallet","content":"Each token holder has its own instance of token wallet contract. Transfer happens in a decentralized fashion - sender token wallet SHOULD send the specific message to the receiver token wallet. Since token wallets have the same code, it's easy for receiver token wallet to check the correctness of sender token wallet. "},{"title":"References​","type":1,"pageTitle":"Fungible Token","url":"standard/TIP-3#references","content":"EIP-20: Token StandardForum FreeTON - TIP3Reference implementation by Broxus "},{"title":"Fungible Token Interface (TIP-3.1)","type":0,"sectionRef":"#","url":"standard/TIP-3.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#abstract","content":"The following standard allows for the implementation of a standard API for tokens within smart contracts. General information about token is stored in the token root contract. Each token holder has its own instance of token wallet contract. Token transfers SHOULD be implemented in P2P fashion, between sender and receiver token wallets. "},{"title":"Motivation​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#motivation","content":"A standard interface allows any tokens on Everscale to be re-used by other applications: from wallets to decentralized exchanges. "},{"title":"Specification​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. "},{"title":"Notes​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#notes","content":"We choose Standard Interface Detection to expose the interfaces that a TIP3 smart contract supports.This standard does not define the external methods to initiate transfer, mint or burn tokens. Though it defines the methods, which MUST be called on a recipient token wallet or token root during these operations.The rules for a token wallet ownership MUST be defined in a child standards.A -1 offset is added to some function IDs derivations, so the preimage of the hash cannot be known, further reducing the chances of a possible collisions. "},{"title":"Token root​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-root","content":"Name​ Returns the name of the token - e.g. &quot;MyToken&quot;. function name() public view responsible returns (string);  Symbol​ Returns the symbol of the token. E.g. “HIX”. function symbol() public view responsible returns (string);  Decimals​ Returns the number of decimals the token uses - e.g. 8, means to divide the token amount by 100000000 to get its user representation. function decimals() public view responsible returns (uint8);  Total supply​ Returns the total token supply. function totalSupply() public view responsible returns (uint128);  Token wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens burn​ Does not have a standard signature, but has a standard function ID 0x192B51B1 obtained as tvm.functionId('acceptBurn(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Decreases token total supply by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptBurn { function acceptBurn(uint128 _value) functionID(0x192B51B1) public; function acceptBurn2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x192B51B1) public; function acceptBurn3(uint128 _value, TvmCell _meta) functionID(0x192B51B1) public; }  Standard interface detection​ interface TIP3TokenRoot { function acceptBurn(uint128 _value) functionID(0x192B51B1) public view responsible; function name() public view responsible returns (string); function symbol() public view responsible returns (string); function decimals() public view responsible returns (uint8); function totalSupply() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token root interface ID is 0x4371D8ED. "},{"title":"Token wallet​","type":1,"pageTitle":"Fungible Token Interface (TIP-3.1)","url":"standard/TIP-3.1#token-wallet","content":"Root​ Returns the token root address. function root() public view responsible returns (address);  Balance​ Returns the token wallet balance. function balance() public view responsible returns (uint128);  Wallet code​ Returns the token wallet code. function walletCode() public view responsible returns (TvmCell);  Accept tokens transfer​ Does not have a standard signature, but has a standard function ID 0x67A0B95F obtained as tvm.functionId('acceptTransfer(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token wallet. Before sending this message, caller token wallet MUST decrease its own balance by _value. If the transfer can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptTransfer { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptTransfer2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x67A0B95F) external; function acceptTransfer3(uint128 _value, TvmCell _meta) functionID(0x67A0B95F) external; }  Accept tokens mint​ Does not have a standard signature, but has a standard function ID 0x4384F298 obtained as tvm.functionId('acceptMint(uint128)') - 1. The uint128 _value parameter MUST be first. The function name and the rest of the parameters are not fixed by this standard and can be reinvented for each substandard. Increases token wallet balance by _value. The contract MUST check that the sender is a correct token root. Before sending this message, token root MUST increase the total supply by _value. If the mint can't be accepted (e.g. invalid sender), this message MUST be bounced. Any function from the following snippet is a valid example: interface TIP3AcceptMint { function acceptMint(uint128 _value) functionID(0x4384F298) external; function acceptMint2(uint128 _value, uint256 _publicKey, address _owner) functionID(0x4384F298) external; function acceptMint3(uint128 _value, TvmCell _meta) functionID(0x4384F298) external; }  On-bounce behaviour​ The acceptTransfer or acceptBurn methods can be bounced, e.g. receiver token wallet has a different code or burning disabled. The token wallet behaviour in these cases should be implemented according to the following rules. Handle acceptTransfer bounce​ Increases token wallet balance according to the value, specified in the bounce body. Handle acceptBurn bounce​ Increases token wallet balance according to the value, specified in the bounce body. Standard interface detection​ interface TIP3TokenWallet { function acceptTransfer(uint128 _value) functionID(0x67A0B95F) external; function acceptMint(uint128 _value) functionID(0x4384F298) external; function root() public view responsible returns (address); function balance() public view responsible returns (uint128); function walletCode() public view responsible returns (TvmCell); }  The token wallet interface ID is 0x4F479FA3. "},{"title":"Non-Fungible Token","type":0,"sectionRef":"#","url":"standard/TIP-4","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#abstract","content":"The following standard describes the basic idea of distributed non-fungible token architecture. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#motivation","content":"The suggested standard differs considerably from Ethereum ERC721 and other smart contract token standards with single registry because of its distributed nature related to Everscale blockchain particularities. Given that Everscale has a storage fee, TIP4 is fully distributed and implies separate storage of each NFT. "},{"title":"Architecture​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#architecture","content":"General information about NFT collection is stored in the NFT collection contract. Each NFT deployed in separate smart contracts and links to NFT collection contract Smart contract architecture based on: Consider asynchronous type of Everscale blockchain. Use callbacks and asynchronous getters;Standardizes one NFT - one smart contract. Gas fee management practicals. Use TIP-6.1 "},{"title":"Non-Fungible Token (TIP-4.1)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#non-fungible-token-tip-41","content":"General information about NFT collection and NFT tokens. All NFT must implement TIP-4.1 "},{"title":"Non-Fungible Token JSON Metadata (TIP-4.2)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#non-fungible-token-json-metadata-tip-42","content":"General information about NFT metadata. TIP-4.2 is optional, but can be used for displaying NFT on marketplaces, wallets and web. "},{"title":"On-chain indexes (TIP-4.3)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#on-chain-indexes-tip-43","content":"On-chain Indexes solves easy and fast searching any data in blockchain. TIP-4.3 is optional, but can be use for find all your NFT with one dApp query. "},{"title":"On-chain storage (TIP-4.4)​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#on-chain-storage-tip-44","content":"Using the Storage contract, you can store NFT-related bytes in blockchain. TIP-4.4 is optional, but can be used for fault tolerance. If off-chain services are unavailable, the user will view NFT-related bytes, because it is stored on-chain. "},{"title":"Authors​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#authors","content":"Author\tCommandAleksand Aleksev\tgrandbazar.io Aleksandr Khramtsov\tbroxus Andrey Nedobylskiy\tsvoi.dev Anton Platonov\tcommunity member Nikita\tnumiz.org Oleg Varnov\tnumiz.org Slava Semenchuk\tscalepunks.com "},{"title":"Implementation​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#implementation","content":"itgold implementation MIT licensed.A library of modular, reusable smart contracts.Samples and tests here "},{"title":"References​","type":1,"pageTitle":"Non-Fungible Token","url":"standard/TIP-4#references","content":"Ethereum EIP-721Solana v1.2.0TON NFT, TON DATATezos TZIP12 "},{"title":"Non-Fungible Token JSON Metadata (TIP-4.2)","type":0,"sectionRef":"#","url":"standard/TIP-4.2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#abstract","content":"Token-specific metadata is stored as a string in smart contract. To facilitate an off-chain working with metadata, it is JSON object. The below metadata structure allows the marketplaces to read and display the details about the assets which your NFTs represent. This standard provides optional JSON fields and contract interface. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#motivation","content":"A standard fields facilitate displaying of NFT data for: wallets, explorers, marketplaces, etc. "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 "},{"title":"JSON metadata​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#json-metadata","content":"Return the metadata as JSON Every TIP4.2 compliant contract must implement the TIP4_2JSON_Metadata interface and TIP-6.1 interfaces pragma ton-solidity &gt;= 0.58.0; interface TIP4_2JSON_Metadata { /// @notice metadata in JSON format /// @return json The JSON string with metadata function getJson() external view responsible returns (string json); }  NOTE The TIP-6.1 identifier for this interface is 0x24D7D5F5. "},{"title":"TIP4_2JSON_Metadata.getJson()​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#tip4_2json_metadatagetjson","content":"function getJson() external view responsible returns (string json);  json (string) - The JSON string with metadata The function return metadata as a JSON string. "},{"title":"Empty JSON metadata​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#empty-json-metadata","content":"Empty JSON metadata is represented as a blank JSON object or an empty string. {}  "},{"title":"JSON metadata type​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#json-metadata-type","content":"Not empty JSON must have &quot;type&quot; field {&quot;type&quot;:&quot;string&quot;}  Application that read JSON metadata use &quot;type&quot; field for parsing standard or custom JSON fields. "},{"title":"JSON metadata type: \"Basic NFT\"​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#json-metadata-type-basic-nft","content":"The Basic NFT use for links to files stores in web. JSON fields contain information about item, files and preview info. The Basic NFT describes fields that must be in JSON Field name\ttype\tValue\tDescriptiontype\tstring\t&quot;Basic NFT&quot;\tConstant name for this type name\tstring Name of the object description\tstring Description of the object preview\tobject Object preview preview.source\tstring Link to object. Contains protocol and data source. Delimiter is : preview.mimetype\tstring Mime type of object files\tarray Array of objects. file.source\tstring Link to object. Contains protocol and data source. Delimiter is : file.mimetype\tstring Mime type of object external_url\tstring URL to website "},{"title":"Example​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#example","content":"{ &quot;type&quot;: &quot;Basic NFT&quot;, &quot;name&quot;: &quot;Sample Name&quot;, &quot;description&quot;: &quot;Hello world!&quot;, &quot;preview&quot;: { &quot;source&quot;: &quot;https://everscale.network/images/Backgrounds/Main/main-hero.png&quot;, &quot;mimetype&quot;: &quot;image/png&quot; }, &quot;files&quot;: [ { &quot;source&quot;: &quot;https://everscale.network/images/Backgrounds/Main/main-hero.png&quot;, &quot;mimetype&quot;: &quot;image/png&quot; } ], &quot;external_url&quot;: &quot;https://everscale.network&quot; }  You can extend Basic NFT type for your custom fields. "},{"title":"How to add the new JSON metadata type?​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#how-to-add-the-new-json-metadata-type","content":"For added new metadata type of TIP-4.2 Create product that use new JSON type.Send PR for change the docs.Explain why it will be in Standard. "},{"title":"References​","type":1,"pageTitle":"Non-Fungible Token JSON Metadata (TIP-4.2)","url":"standard/TIP-4.2#references","content":"Ethereum EIP-721Solana v1.2.0TON NFT, TON DATATezos TZIP12BNS BEP721 "},{"title":"Non-Fungible Token (TIP-4.1)","type":0,"sectionRef":"#","url":"standard/TIP-4.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#abstract","content":"The following standard allows for implementing a standard API for NFTs within smart contracts. General information about NFT collection is stored in the NFT collection contract. Each NFT deployed in separate smart contracts and links to NFT collection contract. This standard provides basic functionality to create, track and transfer NFTs. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#motivation","content":"A standard interface allows any NFT to be re-used by other applications: wallets, explorers, marketplaces, etc. "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119. "},{"title":"Collection​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#collection","content":"The contract represents shared information about NFT collection and logic for creation of NFTs and burn of NFTs. Every TIP4.1 compliant collection contract must implement the TIP4_1Collection interface and TIP-6.1 interfaces pragma ton-solidity &gt;= 0.58.0; interface TIP4_1Collection { /// @notice This event emits when NFTs are created /// @param id Unique NFT id /// @param nft Address NFT contact /// @param owner Address of NFT owner /// @param manager Address of NFT manager /// @param creator Address of creator that initialize mint NFT event NftCreated(uint256 id, address nft, address owner, address manager, address creator); /// @notice This event emits when NFTs are burned /// @param id Unique NFT id /// @param nft Address NFT contact /// @param owner Address of NFT owner when it burned /// @param manager Address of NFT manager when it burned event NftBurned(uint256 id, address nft, address owner, address manager); /// @notice Count active NFTs for this collection /// @return count A count of active NFTs minted by this contract except for burned NFTs function totalSupply() external view responsible returns (uint128 count); /// @notice Returns the NFT code /// @return code Returns the NFT code as TvmCell function nftCode() external view responsible returns (TvmCell code); /// @notice Returns the NFT code hash /// @return codeHash Returns the NFT code hash function nftCodeHash() external view responsible returns (uint256 codeHash); /// @notice Computes NFT address by unique NFT id /// @dev Return unique address for all Ids. You find nothing by address for not a valid NFT /// @param id Unique NFT id /// @return nft Returns address of NFT contract function nftAddress(uint256 id) external view responsible returns (address nft); }  NOTE The TIP-6.1 identifier for this interface is 0x1217AAAB. "},{"title":"TIP4_1Collection.totalSupply()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectiontotalsupply","content":"function totalSupply() public view responsible returns (uint128 count);  count (uint128) - A count of active NFTs The function return count of active NFTs. Value increased by one when NFT minted and decreased by one when NFT burned. "},{"title":"TIP4_1Collection.nftCode()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectionnftcode","content":"function nftCode() public view responsible returns (TvmCell code);  code (TvmCell) - NFT code NFTs is a smart contract deployed from collection smart contract use nftCode and id. "},{"title":"TIP4_1Collection.nftCodeHash()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectionnftcodehash","content":"function nftCodeHash() public view responsible returns (uint256 codeHash);  codeHash (uint256) - NFT codeHash A codeHash allows search all smart contracts using base dApp functionality. "},{"title":"TIP4_1Collection.nftAddress()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1collectionnftaddress","content":"function nftAddress(uint256 id) public view responsible returns (address nft);  id (uint256) - Unique NFT idnft (address) - The NFT address Computes NFT address by unique NFT id. You can check the NFT for availability using base dApp functionality. "},{"title":"Events​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#events","content":"event NftCreated(uint256 id, address nft, address owner, address manager, address creator); event NftBurned(uint256 id, address nft, address owner, address manager);  id (uint256) - Unique NFT idnft (address) - The NFT addressowner (address) - The initial\\last owner of the NFTmanager (address) - The initial\\last manager of the NFTcreator (address) - The initial address who initiate NFT deploy You must emit NftCreated event when NFT minted. You must emit NftBurned event when NFT burned. "},{"title":"Mint and burn NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#mint-and-burn-nft","content":"A function's signature is not included in the specification. See the Events for your responsibilities when creating or burning NFTs. "},{"title":"NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#nft","content":"The contract represents information about current NFT and control logic. Each NFT contains two roles: owner logicmanager logic The owner’s address is the address that owns this NFT. The owner can see NFT in wallets, marketplaces, apps. The owner can use the NFT for authorization, for proof in games etc. Manager address is the address that controls this NFT. Manager can burn NFT, can change the owner or change the manager (transfer the manager role). Owner address and manager address can be same usually. When an NFT is put up for sale, it means that the manager's address is the address of the smart contract with the sell logic. It's same for farming logic or custom logic for use NFT. Good practice is to set a manager address to a new owner address when owner changed. Every TIP4.1 compliant NFT contract must implement the TIP4_1NFT interface and TIP-6.1 interfaces. pragma ton-solidity &gt;= 0.58.0; interface TIP4_1NFT { struct CallbackParams { uint128 value; // ever value will be sent to address TvmCell payload; // custom payload will be proxied to address } /// @notice The event emits when NFT is created /// @dev Emit the event when NFT is ready to use /// @param id Unique NFT id /// @param owner Address of NFT owner /// @param manager Address of NFT manager /// @param collection Address of collection smart contract that mint the NFT event NftCreated(uint256 id, address owner, address manager, address collection); /// @notice The event emits when NFT owner changed /// @param oldOwner Address of NFT owner before owner changed /// @param newOwner Address of new NFT owner event OwnerChanged(address oldOwner, address newOwner); /// @notice The event emits when NFT manager changed /// @param oldManager Address of NFT manager before manager changed /// @param newManager Address of new NFT manager event ManagerChanged(address oldManager, address newManager); /// @param id Unique NFT id /// @param owner Address of NFT owner /// @param manager Address of NFT manager /// @param collection Address of collection smart contract, that mint the NFT event NftBurned(uint256 id, address owner, address manager, address collection); /// @notice NFT info /// @return id Unique NFT id /// @return owner Address of NFT owner /// @return manager Address of NFT manager /// @return collection Address of collection smart contract function getInfo() external view responsible returns(uint256 id, address owner, address manager, address collection); /// @notice Change NFT owner /// @dev Invoked from manager address only /// @dev Emit OwnerChanged /// @param newOwner New owner of NFT /// @param sendGasTo Address to send remaining gas /// @param callbacks Callbacks array to send by addresses. It can be empty function changeOwner(address newOwner, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external; /// @notice Change NFT manager /// @dev Invoked from manager address only /// @dev Emit ManagerChanged /// @param newManager New manager of NFT /// @param sendGasTo Address to send remaining gas /// @param callbacks Callbacks array to send by addresses. It can be empty function changeManager(address newManager, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external; /// @notice Change NFT owner and manager /// @dev Invoked from manager address only /// @dev Emit OwnerChanged /// @dev Emit ManagerChanged /// @param to New NFT owner and manager /// @param sendGasTo Address to send remaining gas /// @param callbacks Callbacks array to send by addresses. It can be empty function transfer(address to, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external; }  NOTE The TIP-6.1 identifier for this interface is 0x78084F7E. "},{"title":"TIP4_1NFT.getInfo()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nftgetinfo","content":"function getInfo() public view responsible returns(uint256 id, address owner, address manager, address collection);  id (uint256) - Unique NFT idowner (address) - The owner of the NFTmanager (address) - The manager of the NFTcollection (address) - The NFT collection address "},{"title":"TIP4_1NFT.changeOwner()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nftchangeowner","content":"function changeOwner(address newOwner, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external;  newOwner (address) - New owner of NFTsendGasTo (address) - Address to send remaining gas. It sent to all callback addresses, toocallbacks (mapping(address =&gt; CallbackParams)) - Callbacks uses for asynchronous calls to another addresses CallbackParams: Field name\ttype\tDescriptionvalue\tuint128\tEver values that send with callback payload\tTvmCell\tCustom payload will send to address Change NFT owner. You must emit OwnerChanged event when NFT owner changed. The NFT sends callbacks if callbacks not empty. "},{"title":"TIP4_1NFT.changeManager()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nftchangemanager","content":"function changeManager(address newManager, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external;  newManager (address) - New manager of NFTsendGasTo (address) - Address to send remaining gas. It sent to all callback addresses toocallbacks (mapping(address =&gt; CallbackParams)) - Callbacks uses for asynchronous calls to another addresses CallbackParams: Field name\ttype\tDescriptionvalue\tuint128\tEver values that send with callback payload\tTvmCell\tCustom payload will send to address Change NFT manager. You must emit ManagerChanged event when NFT owner changed. The NFT sends callbacks if callbacks not empty. "},{"title":"TIP4_1NFT.transfer()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#tip4_1nfttransfer","content":"function transfer(address to, address sendGasTo, mapping(address =&gt; CallbackParams) callbacks) external;  to (address) - New NFT owner and managersendGasTo (address) - Address to send remaining gas. It sent to all callback addresses toocallbacks (mapping(address =&gt; CallbackParams)) - Callbacks uses for asynchronous calls to another addresses CallbackParams: Field name\ttype\tDescriptionvalue\tuint128\tEver values that send with callback payload\tTvmCell\tCustom payload will send to address Change NFT manager. You must emit OwnerChanged and ManagerChanged events when NFT owner changed. The NFT sends callbacks if callbacks not empty. "},{"title":"NFT events​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#nft-events","content":"event NftCreated(uint256 id, address owner, address manager, address collection); event OwnerChanged(address oldOwner, address newOwner); event ManagerChanged(address oldManager, address newManager); event NftBurned(uint256 id, address owner, address manager, address collection);  id (uint256) - Unique NFT idowner (address) - The initial\\last owner of the NFTmanager (address) - The initial\\last manager of the NFTcollection (address) - The collection address who initiate NFT deploy You must emit NftCreated event, when NFT created, initialized and ready to use. You must emit OwnerChanged event every time when owner address changed. You must emit ManagerChanged event every time when manager address changed. You must emit NftBurned event when NFT burned. Events emit when NFTs are created, burned or moved to a new owner\\manager. "},{"title":"Mint NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#mint-nft","content":"A function and constructor signature is not included in the specification. The NFT must deploy from collection smart contract. The NFT must emit NftCreated event after NFT deployed and ready to use. See the [NFT events](#NFT events) for your responsibilities when creating NFT. "},{"title":"Burn NFT​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#burn-nft","content":"A function signature is not included in the specification. The NFT must emit NftBurned event before NFT burned. The NFT must send an internal message to collection contract before NFT burned. See the Events for your responsibilities when burning NFT. "},{"title":"ChangeOwner callback processing​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#changeowner-callback-processing","content":"Smart contract that processing callback message must implement. interface INftChangeOwner { struct CallbackParams { uint128 value; // ever value will send to address TvmCell payload; // custom payload will be proxied to address } /// @notice change owner callback processing /// @param id Unique NFT id /// @param manager Address of NFT manager /// @param oldOwner Address of NFT owner before owner changed /// @param newOwner Address of new NFT owner /// @param collection Address of collection smart contract, that mint the NFT /// @param sendGasTo Address to send remaining gas /// @param payload Custom payload function onNftChangeOwner( uint256 id, address manager, address oldOwner, address newOwner, address collection, address sendGasTo, TvmCell payload ) external; }  "},{"title":"ChangeManager callback processing​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#changemanager-callback-processing","content":"Smart contract that processing callback message must implement. interface INftChangeManager { struct CallbackParams { uint128 value; // ever value will send to address TvmCell payload; // custom payload will proxying to address } /// @notice change owner callback processing /// @param id Unique NFT id /// @param owner Address of NFT owner /// @param oldManager Address of NFT manager before manager changed /// @param newManager Address of new NFT manager /// @param collection Address of collection smart contract that mint the NFT /// @param sendGasTo - Address to send remaining gas /// @param payload - Custom payload function onNftChangeManager( uint256 id, address owner, address oldManager, address newManager, address collection, address sendGasTo, TvmCell payload ) external; }  "},{"title":"Transfer callback processing​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#transfer-callback-processing","content":"Smart contract that processing callback message must implement. interface INftTransfer { struct CallbackParams { uint128 value; // ever value will send to address TvmCell payload; // custom payload will proxying to address } /// @notice change owner callback processing /// @param id Unique NFT id /// @param oldOwner Address of NFT owner before transfer /// @param newOwner Address of new NFT owner /// @param oldManager Address of NFT manager before transfer /// @param newManager Address of new NFT manager /// @param collection Address of collection smart contract that mint the NFT /// @param sendGasTo Address to send remaining gas /// @param payload Custom payload function onNftTransfer( uint256 id, address oldOwner, address newOwner, address oldManager, address newManager, address collection, address sendGasTo, TvmCell payload ) external; }  "},{"title":"Visualization​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#visualization","content":""},{"title":"Legend​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#legend","content":" "},{"title":"Collection deployment​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#collection-deployment","content":" "},{"title":"Minting​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#minting","content":" "},{"title":"Burning​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#burning","content":" "},{"title":"Change owner​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#change-owner","content":" "},{"title":"Change manager​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#change-manager","content":" "},{"title":"Example how to use NFT. Put on sell using changeManager()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-put-on-sell-using-changemanager","content":" "},{"title":"Example how to use NFT. Buy using changeOwner()​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-buy-using-changeowner","content":" "},{"title":"Example how to use NFT. Put on sell by TIP-3.1 tokens​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-put-on-sell-by-tip-31-tokens","content":" "},{"title":"Example how to use NFT. Buy for TIP-3.1 tokens​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#example-how-to-use-nft-buy-for-tip-31-tokens","content":" "},{"title":"References​","type":1,"pageTitle":"Non-Fungible Token (TIP-4.1)","url":"standard/TIP-4.1#references","content":"Ethereum EIP-721Solana v1.2.0TON NFT, TON DATATezos TZIP12 "},{"title":"Non-Fungible Token On-chain storage (TIP-4.4)","type":0,"sectionRef":"#","url":"standard/TIP-4.4","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#abstract","content":"Using the Storage contract, you can store NFT-related bytes in blockchain "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#motivation","content":"Fault tolerance. If off-chain services are unavailable, the user will view NFT-related bytes, because it is stored on-chain. "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 "},{"title":"Contracts​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#contracts","content":"Collection - TIP4.1 contract that minted token and store Storage contract codeNFT - TIP4.1 contract that store token information and Storage contract addressStorage - contract that store token byte content. Storage is independent. Storage doesn’t store NFT address because NFT contract address can be changed by burning and redeployment from another collection. "},{"title":"Collection​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#collection","content":"Every TIP-4.1 Collection contract must implement TIP4_4Collection pragma ton-solidity &gt;= 0.58.0; interface TIP4_4Collection { function storageCode() external view responsible returns (TvmCell code); function storageCodeHash() external view responsible returns (uint256 codeHash); function resolveStorage(address nft) external view responsible returns (address addr); }  NOTE The TIP-6.1 identifier for this interface is 0x6302A6F8 "},{"title":"TIP4_4Collection.storageCode()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4collectionstoragecode","content":"function storageCode() external view responsible returns (TvmCell code);  code (TvmCell) - storage contract code "},{"title":"TIP4_4Collection.storageCode()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4collectionstoragecode-1","content":"function storageCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - storage contract code hash "},{"title":"TIP4_4Collection.resolveStorage()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4collectionresolvestorage","content":"function resolveStorage(address nft) external view responsible returns (address addr);  nft (address) - token contract addressaddr (address) - storage contract address "},{"title":"NFT​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#nft","content":"Every TIP-4.1 NFT contract must implement TIP4_4NFT pragma ton-solidity &gt;= 0.58.0; interface TIP4_4NFT { function onStorageFillComplete(address gasReceiver) external; function getStorage() external view responsible returns (address addr); }  NOTE The TIP-6.1 identifier for this interface is 0x009DC09A "},{"title":"TIP4_4NFT.onStorageFillComplete()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4nftonstoragefillcomplete","content":"function onStorageFillComplete(address gasReceiver) external;  gasReceiver (address) - address of contract that receive all remaining contract balance then last chunk filled Calling the Storage.fill() on storage contract that fills the last chunk should call TIP4_4NFT.onStorageFillComplete() on token contract "},{"title":"TIP4_4NFT.getStorage()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4nftgetstorage","content":"function getStorage() external view responsible returns (address addr);  addr (address) - storage contract address "},{"title":"Storage​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#storage","content":"Every Storage contract must implement TIP4_4Storage pragma ton-solidity &gt;= 0.58.0; interface TIP4_4Storage { function fill(uint8 id, bytes chunk, address gasReceiver) external; function getInfo() external view responsible returns ( address nft, address collection, string mimeType, mapping(uint8 =&gt; bytes) content ); }  NOTE The TIP-6.1 identifier for this interface is 0x4855B0B8 "},{"title":"TIP4_4Storage.fill()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4storagefill","content":"function fill(uint8 id, bytes chunk, address gasReceiver) external;  id (uint8) - chunk number. From 0 to 255bytes (chunk) - data. Max size of data is limited by external message payload size. Maximum size external message payload size is 16KB at 2022-03-18.gasReceiver (address) - address of contract that receive all remaining contract balance then last chunk filled. "},{"title":"TIP4_4Storage.getInfo()​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#tip4_4storagegetinfo","content":"function getInfo() external view responsible returns ( address nft, address collection, string mimeType, mapping(uint8 =&gt; bytes) chunks );  nft (address) - token contract addresscollection (address) - collection token contract addressmimeType (string) - MIME types are defined and standardized in IETF's RFC 6838chunks (mapping(uint8 =&gt; bytes)) - byte content. Maximum content size is 256 chunks * chunk size. Max size of data is limited by external message payload size. Maximum size external message payload size is 16KB at 2022-03-18 Maximum content size is 256 * 16KB = 4MB at 2022-03-18. "},{"title":"Visualization​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#visualization","content":""},{"title":"Legend​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#legend","content":" "},{"title":"NFT minting with Storage​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#nft-minting-with-storage","content":" "},{"title":"Storage filling​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#storage-filling","content":" "},{"title":"Storage with Index​","type":1,"pageTitle":"Non-Fungible Token On-chain storage (TIP-4.4)","url":"standard/TIP-4.4#storage-with-index","content":"How to interaction on-chain indexes and Storage contracts "},{"title":"URI scheme","type":0,"sectionRef":"#","url":"standard/TIP-5","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"URI scheme","url":"standard/TIP-5#motivation","content":"TDB "},{"title":"Non-Fungible Token on-chain indexes (TIP-4.3)","type":0,"sectionRef":"#","url":"standard/TIP-4.3","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#abstract","content":"Using the Index contract code, you can find all your NFT with one dApp query. This makes blockchain application less dependent on different off-chain parsers and indexers On-chain Indexes solves easy and fast searching any data in blockchain. This document shows standard for basic query. Any developer can get an idea of this solution and realize his own on-chain index. "},{"title":"Motivation​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#motivation","content":"A standard interface allows search all Collection and all NFT by owner using base dApp functionality "},{"title":"Specification​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#specification","content":"The keywords “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119 "},{"title":"Contracts​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#contracts","content":"Collection - TIP4.1 contract that minted tokenNFT - TIP4.1 contract that store token informationIndexBasis - contract, that helps to find all collections by the code hash of whichIndex - contract, that helps to find: All user tokens in current collection using owner address and collection addressAll user tokens in all collections using owner address code of IndexBasis and Index contracts and code hash of contracts is fixed and CANNOT BE CHANGED "},{"title":"IIndexBasis​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasis","content":"pragma ton-solidity &gt;= 0.58.0; interface IIndexBasis { function getInfo() external view responsible returns (address collection); function destruct(address gasReceiver) external; }  "},{"title":"IndexBasis​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#indexbasis","content":"pragma ton-solidity &gt;= 0.58.0; import 'IIndexBasis.sol'; /** * Errors * 101 - Method for collection only **/ contract IndexBasis is IIndexBasis { address static _collection; modifier onlyCollection() { require(msg.sender == _collection, 101, &quot;Method for collection only&quot;); tvm.accept(); _; } constructor() public onlyCollection {} function getInfo() override public view responsible returns (address collection) { return {value: 0, flag: 64} _collection; } function destruct(address gasReceiver) override public onlyCollection { selfdestruct(gasReceiver); } }  Code hash of IndexBasis compiled by TVMCompiler v0.58.2 and TVM-linker v0.14.51 without salting is 2359f897c9527073b1c95140c670089aa5ab825f5fd1bd453db803fbab47def2 "},{"title":"IIndexBasis.getInfo()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasisgetinfo","content":"function getInfo() external view responsible returns (address collection);  collection (address) - collection token contract address "},{"title":"IIndexBasis.destruct()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasisdestruct","content":"function destruct(address gasReceiver) external;  gasReceiver (address) - address of contract that receives all remaining contract balance after selfdestruct() call "},{"title":"IIndex​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindex","content":"pragma ton-solidity &gt;= 0.58.0; interface IIndex { function getInfo() external view responsible returns ( address collection, address owner, address nft ); function destruct(address gasReceiver) external; }  "},{"title":"Index​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#index","content":"pragma ton-solidity &gt;= 0.58.0; import 'IIndex.sol'; /** * Errors * 101 - Method for NFT only * 102 - Salt doesn't contain any value **/ contract Index is IIndex { address static _nft; address _collection; address _owner; constructor(address collection) public { optional(TvmCell) salt = tvm.codeSalt(tvm.code()); require(salt.hasValue(), 102, &quot;Salt doesn't contain any value&quot;); (, address collection_, address owner) = salt .get() .toSlice() .decode(string, address, address); require(msg.sender == _nft); tvm.accept(); _collection = collection_; _owner = owner; if (collection_.value == 0) { _collection = collection; } } function getInfo() override public view responsible returns ( address collection, address owner, address nft ) { return {value: 0, flag: 64} ( _collection, _owner, _nft ); } function destruct(address gasReceiver) override public { require(msg.sender == _nft, 101, &quot;Method for NFT only&quot;); selfdestruct(gasReceiver); } }  Code hash of Index compiled by TVMCompiler v0.58.2 and TVM-linker v0.14.51 without salting is 61e5f39a693dc133ea8faf3e80fac069250161b0bced3790c20ae234ce6fd866 "},{"title":"Index.getInfo()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#indexgetinfo","content":"function getInfo() external view responsible returns ( address collection, address owner, address nft );  collection (address) - collection token contract addressowner (address) - token owner contract addressnft (address) - token contract address "},{"title":"IIndexBasis.destruct()​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#iindexbasisdestruct-1","content":"function destruct(address gasReceiver) external;  gasReceiver (address) - address of contract that receives all remaining contract balance after selfdestruct() call "},{"title":"Collection​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#collection","content":"TIP-4.1 Collection contract must implement the TIP4_3Collection interface and TIP-6.1 interfacesTIP-4.1 Collection contract must deploy IndexBasis contract after deployment with code saltTIP-4.1 Collection contract must destuct() IndexBasis contracts before collection destruction "},{"title":"TIP4_3Collection​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#tip4_3collection","content":"pragma ton-solidity &gt;= 0.58.0; interface TIP4_3Collection { function indexBasisCode() external view responsible returns (TvmCell code); function indexBasisCodeHash() external view responsible returns (uint256 hash); function indexCode() external view responsible returns (TvmCell code); function indexCodeHash() external view responsible returns (uint256 hash); function resolveIndexBasis() external view responsible returns (address indexBasis); }  NOTE The TIP-6.1 identifier for this interface is 0x4387BBFB TIP4_3Collection.indexBasisCode()​ function indexBasisCode() external view responsible returns (TvmCell code);  code (TvmCell) - basis index contract code TIP4_3Collection.indexBasisCodeHash()​ function indexBasisCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - basis index contract code hash TIP4_3Collection.indexCode()​ function indexCode() external view responsible returns (TvmCell code);  code (TvmCell) - index contract code TIP4_3Collection.indexCodeHash()​ function indexCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - index contract code hash TIP4_3Collection.indexBasis()​ function resolveIndexBasis() external view responsible returns (address indexBasis);  indexBasis (address) - basis index contract address "},{"title":"Code salt parameters​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#code-salt-parameters","content":"stamp (string) - stamp that determine type of index. stamp = &quot;nft&quot;; for all NFT indexes "},{"title":"Example of IndexBasis deployment​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#example-of-indexbasis-deployment","content":"function deployIndexBasis(TvmCell codeIndex, address collection, uint128 value) private pure { string stamp = &quot;nft&quot;; TvmBuilder salt; salt.store(stamp); TvmCell code = tvm.setCodeSalt(codeIndex, salt.toCell()); TvmCell stateInit = tvm.buildStateInit({ contr: IndexBasis, varInit: {_collection: collection}, code: code }); new IndexBasis{stateInit: stateInit, value: value}(); }  "},{"title":"NFT​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#nft","content":"TIP-4.1 Collection contract must implement the TIP4_3NFT interface and TIP-6.1 interfacesTIP-4.1 NFT contract must deploy at least two Index contract after deployment with different code salt With zero collection address collection = &quot;0:0000000000000000000000000000000000000000000000000000000000000000&quot; in code saltWith non-zero collection address collection = &quot;0:3bd8…&quot; in code salt TIP-4.1 NFT contract must destuct() Index before NFT burningTIP-4.1 NFT contract must destuct() old Index contacts and deploy new Index contracts if owner changed "},{"title":"TIP4_3NFT​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#tip4_3nft","content":"pragma ton-solidity &gt;= 0.58.0; interface TIP4_3NFT { function indexCode() external view responsible returns (TvmCell code); function indexCodeHash() external view responsible returns (uint256 hash); function resolveIndex(address collection, address owner) external view responsible returns (address index); }  NOTE The TIP-6.1 identifier for this interface is 0x4DF6250B TIP4_3NFT.indexCode()​ function indexCode() external view responsible returns (TvmCell code);  code (TvmCell) - index contract code TIP4_3NFT.indexCodeHash()​ function indexCodeHash() external view responsible returns (uint256 hash);  hash (uint256) - basis index contract code hash TIP4_3NFT.resolveIndex()​ function resolveIndex(address collection, address owner) external view responsible returns (address index);  collection (address) - collection token contract addressowner (address) - token owner contract addressindex (address) - index contract address "},{"title":"Code salt parameters​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#code-salt-parameters-1","content":"stamp (string) - stamp that determine type of index. stamp = &quot;nft&quot;; for all NFT indexescollection (address) - collection token contract addressowner (address) - token owner contract address "},{"title":"Example of Index deployment​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#example-of-index-deployment","content":"function deployIndex(TvmCell codeIndex, address nft, address collection, address owner, uint128 value) private pure { string stamp = &quot;nft&quot;; TvmBuilder salt; salt.store(stamp, collection, owner); TvmCell code = tvm.setCodeSalt(codeIndex, salt.toCell()); TvmCell stateInit = tvm.buildStateInit({ contr: Index, varInit: {_nft: nft}, code: code }); new Index{stateInit: stateInit, value: value}(); }  "},{"title":"Example of dApp query for search by index​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#example-of-dapp-query-for-search-by-index","content":"query { accounts( filter: { code_hash: { eq: &quot;207dc560c5956de1a2c1479356f8f3ee70a59767db2bf4788b1d61ad42cdad82&quot; } } ){ id } }  Part of response example { &quot;data&quot;: { &quot;accounts&quot;: [ { &quot;id&quot;: &quot;0:000001b0422f6a7069786fa9a27aa7bb8042f58e1df01dfebc51dcb2baa5eeae&quot; }, { &quot;id&quot;: &quot;0:00022772794253c1bf8cb4fa59d6161d574033c13d881f3eea14675b911e61b0&quot; } ] } }  "},{"title":"Source code​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#source-code","content":"link "},{"title":"Visualization​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#visualization","content":""},{"title":"Legend​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#legend","content":" "},{"title":"IndexBasis deployment for Collection​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#indexbasis-deployment-for-collection","content":" "},{"title":"Index contracts deployment for NFT​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#index-contracts-deployment-for-nft","content":" "},{"title":"Redeploy Index contracts after changeOwner​","type":1,"pageTitle":"Non-Fungible Token on-chain indexes (TIP-4.3)","url":"standard/TIP-4.3#redeploy-index-contracts-after-changeowner","content":" "},{"title":"Fungible token payment link (TIP-5.1)","type":0,"sectionRef":"#","url":"standard/TIP-5.1","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Fungible token payment link (TIP-5.1)","url":"standard/TIP-5.1#motivation","content":"TDB "},{"title":"Non-fungible token payment link (TIP-5.2)","type":0,"sectionRef":"#","url":"standard/TIP-5.2","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#abstract","content":"TDB "},{"title":"Motivation​","type":1,"pageTitle":"Non-fungible token payment link (TIP-5.2)","url":"standard/TIP-5.2#motivation","content":"TDB "},{"title":"Standard Interface Detection","type":0,"sectionRef":"#","url":"standard/TIP-6","content":"","keywords":""},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection","url":"standard/TIP-6#abstract","content":"Smart contracts in Everscale can implement a wide variety of functionality - wallets, tokens, exchanges and so on. We need a standard way to determine the type of smart contract without relying on knowledge of its internal structure. "},{"title":"Standard Interface Detection Interface (TIP-6.1)","type":0,"sectionRef":"#","url":"standard/TIP-6.1","content":"","keywords":""},{"title":"Simple summary​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#simple-summary","content":"Creates a standard method to publish and detect what interfaces a smart contract implements. "},{"title":"Abstract​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#abstract","content":"Herein, we standardize the following: How interfaces are identifiedHow a contract will publish the interfaces it implements "},{"title":"Motivation​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#motivation","content":"For some “standard interfaces” like the token interface, it is sometimes useful to query whether a contract supports the interface and if yes, which version of the interface, in order to adapt the way in which the contract is to be interacted with. This proposal standardizes the concept of interfaces and standardizes the identification (naming) of interfaces. "},{"title":"Specification​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#specification","content":""},{"title":"How interfaces are identified​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#how-interfaces-are-identified","content":"For this standard, an interface is a set of function selectors as defined by the Solidity ABI. This a subset of Solidity’s concept of interfaces and the interface keyword definition which also defines return types, mutability and events. We define the interface identifier as the XOR of all function selectors in the interface. This code example shows how to calculate an interface identifier: Solidity​ interface Solidity101 { function hello() external pure; function world(int) external pure; } contract Selector { function calculateSelector() public view returns (bytes4) { Solidity101 i; return bytes4(tvm.functionId(i.hello) ^ tvm.functionId(i.world)); } }  How a Contract will Publish the Interfaces it Implements​ A contract that is compliant with TIP6.1 shall implement the following interface: Solidity​ interface TIP6 { /// @notice Query if a contract implements an interface /// @param interfaceID The interface identifier, as specified in TIP6.1 /// @dev Interface identification is specified in TIP6.1. /// @return `true` if the contract implements `interfaceID` and /// `interfaceID` is not 0xffffffff, `false` otherwise function supportsInterface(bytes4 interfaceID) external view responsible returns (bool); }  The interface identifier for this interface is 0x3204EC29. You can calculate this by running tvm.functionId('supportsInterface(bytes4)'); or using the Selector contract above. Therefore, the implementing contract will have a supportsInterface function that returns: true when interfaceID is 0x3204EC29 (TIP6.1 interface)false when interfaceID is 0xfffffffftrue for any other interfaceID this contract implementsfalse for any other interfaceID "},{"title":"References​","type":1,"pageTitle":"Standard Interface Detection Interface (TIP-6.1)","url":"standard/TIP-6.1#references","content":"EIP-165: Standard Interface Detection "},{"title":"What is TIP? (TIP-0)","type":0,"sectionRef":"#","url":"standard/workflow","content":"What is TIP? (TIP-0) TIP — Trustless Improvement Proposal (TIPs) describe standards for the Everscale blockchain. They may include anything that the community considers in need of improvement or standardization. That can be specifications for core protocol, description of interfaces, smart contract standards and so on. I propose a more relaxed structure more closely resembling Bitcoin BIPs but with quite different proccess (see below). Each TIP should have the following parts (which are heavily copy-pasted from BIP requirements): Preamble — Headers containing metadata about the TIP;Abstract — A short (~200 word) description of the technical issue being addressed;Copyright — The TIP must be explicitly licensed under acceptable copyright terms;Specification — The technical specification should describe the syntax and semantics of any new feature;The specification should be detailed enough to allow competing, interoperable implementations;Motivation — The motivation is critical for TIPs that want to change the Everscale protocol. It should clearly explain why the existing protocol is inadequate to address the problem that the TIP solves;Rationale — The rationale fleshes out the specification by describing what motivated the design and why particular design decisions were made. It should describe alternate designs that were considered and related work. The rationale should provide evidence of consensus within the community and discuss important objections or concerns raised during discussion;Backwards compatibility — All TIPs that introduce backwards incompatibilities must include a section describing these incompatibilities and their severity. The TIP must explain how the author proposes to deal with these incompatibilities; Each TIP should pass the following process of acceptance: Proposal → Discussion → Community Voting → Reference Implementations Contest → Final TIP with Reference Implementations Reference implementation — The reference implementation must be completed before any TIP is given status Final, but it need not be completed before the TIP is accepted. It is better to finish the specification and rationale first and reach consensus on it before writing code. The final implementation must include test code and documentation appropriate for the Everscale protocol.","keywords":""},{"title":"Delegate","type":0,"sectionRef":"#","url":"validate/delegate","content":"Delegate","keywords":""},{"title":"Contributing","type":0,"sectionRef":"#","url":"validate/contributing","content":"Contributing","keywords":""},{"title":"Monitoring","type":0,"sectionRef":"#","url":"validate/monitoring","content":"Monitoring","keywords":""},{"title":"Economics","type":0,"sectionRef":"#","url":"validate/economics","content":"Economics","keywords":""},{"title":"Run Mainnet Node","type":0,"sectionRef":"#","url":"validate/run-validator/run-mainnet-node","content":"Run Mainnet Node","keywords":""},{"title":"Run testnet node","type":0,"sectionRef":"#","url":"validate/run-validator/run-testnet-node","content":"Run testnet node","keywords":""},{"title":"System requirements","type":0,"sectionRef":"#","url":"validate/run-validator/system-requirements","content":"System requirements","keywords":""},{"title":"Update Validator","type":0,"sectionRef":"#","url":"validate/run-validator/update-validator","content":"Update Validator","keywords":""},{"title":"Validator elections","type":0,"sectionRef":"#","url":"validate/run-validator/validator-elections","content":"Validator elections","keywords":""},{"title":"Staking","type":0,"sectionRef":"#","url":"validate/staking","content":"Staking","keywords":""},{"title":"FAQ","type":0,"sectionRef":"#","url":"validate/troubleshooting/faq","content":"FAQ","keywords":""},{"title":"Node upgrades","type":0,"sectionRef":"#","url":"validate/troubleshooting/node-upgrades","content":"Node upgrades","keywords":""},{"title":"Getting started","type":0,"sectionRef":"#","url":"validate/tutorial/getting-started","content":"Getting started","keywords":""},{"title":"How to stake","type":0,"sectionRef":"#","url":"validate/tutorial/how-to-stake","content":"How to stake","keywords":""},{"title":"How to vote","type":0,"sectionRef":"#","url":"validate/tutorial/how-to-vote","content":"How to vote","keywords":""}]